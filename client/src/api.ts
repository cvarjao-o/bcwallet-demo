/**
 * faber.agent
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.7.3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AMLRecord {
    'aml'?: { [key: string]: string; };
    'amlContext'?: string;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aml",
            "baseName": "aml",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "amlContext",
            "baseName": "amlContext",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AMLRecord.attributeTypeMap;
    }
}

export class ActionMenuFetchResult {
    /**
    * Action menu
    */
    'result'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ActionMenuFetchResult.attributeTypeMap;
    }
}

export class ActionMenuModulesResult {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ActionMenuModulesResult.attributeTypeMap;
    }
}

export class AdminAPIMessageTracing {
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AdminAPIMessageTracing.attributeTypeMap;
    }
}

export class AdminConfig {
    /**
    * Configuration settings
    */
    'config'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "config",
            "baseName": "config",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return AdminConfig.attributeTypeMap;
    }
}

export class AdminMediationDeny {
    /**
    * List of mediator rules for recipient
    */
    'mediatorTerms'?: Array<string>;
    /**
    * List of recipient rules for mediation
    */
    'recipientTerms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mediatorTerms",
            "baseName": "mediator_terms",
            "type": "Array<string>"
        },
        {
            "name": "recipientTerms",
            "baseName": "recipient_terms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminMediationDeny.attributeTypeMap;
    }
}

export class AdminModules {
    /**
    * List of admin modules
    */
    'result'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminModules.attributeTypeMap;
    }
}

export class AdminReset {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminReset.attributeTypeMap;
    }
}

export class AdminShutdown {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminShutdown.attributeTypeMap;
    }
}

export class AdminStatus {
    /**
    * Conductor statistics
    */
    'conductor'?: any;
    /**
    * Default label
    */
    'label'?: string;
    /**
    * Timing results
    */
    'timing'?: any;
    /**
    * Version code
    */
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "conductor",
            "baseName": "conductor",
            "type": "any"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "timing",
            "baseName": "timing",
            "type": "any"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminStatus.attributeTypeMap;
    }
}

export class AdminStatusLiveliness {
    /**
    * Liveliness status
    */
    'alive'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alive",
            "baseName": "alive",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AdminStatusLiveliness.attributeTypeMap;
    }
}

export class AdminStatusReadiness {
    /**
    * Readiness status
    */
    'ready'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ready",
            "baseName": "ready",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AdminStatusReadiness.attributeTypeMap;
    }
}

export class AttachDecorator {
    /**
    * Attachment identifier
    */
    'id'?: string;
    /**
    * Byte count of data included by reference
    */
    'byteCount'?: number;
    'data': AttachDecoratorData;
    /**
    * Human-readable description of content
    */
    'description'?: string;
    /**
    * File name
    */
    'filename'?: string;
    /**
    * Hint regarding last modification datetime, in ISO-8601 format
    */
    'lastmodTime'?: string;
    /**
    * MIME type
    */
    'mimeType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "byteCount",
            "baseName": "byte_count",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "AttachDecoratorData"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "lastmodTime",
            "baseName": "lastmod_time",
            "type": "string"
        },
        {
            "name": "mimeType",
            "baseName": "mime-type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecorator.attributeTypeMap;
    }
}

export class AttachDecoratorData {
    /**
    * Base64-encoded data
    */
    'base64'?: string;
    /**
    * JSON-serialized data
    */
    'json'?: any;
    /**
    * Detached Java Web Signature
    */
    'jws'?: any;
    /**
    * List of hypertext links to data
    */
    'links'?: Array<string>;
    /**
    * SHA256 hash (binhex encoded) of content
    */
    'sha256'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base64",
            "baseName": "base64",
            "type": "string"
        },
        {
            "name": "json",
            "baseName": "json",
            "type": "any"
        },
        {
            "name": "jws",
            "baseName": "jws",
            "type": "any"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Array<string>"
        },
        {
            "name": "sha256",
            "baseName": "sha256",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecoratorData.attributeTypeMap;
    }
}

export class AttachDecoratorData1JWS {
    'header': AttachDecoratorDataJWSHeader;
    /**
    * protected JWS header
    */
    '_protected'?: string;
    /**
    * signature
    */
    'signature': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "AttachDecoratorDataJWSHeader"
        },
        {
            "name": "_protected",
            "baseName": "protected",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecoratorData1JWS.attributeTypeMap;
    }
}

export class AttachDecoratorDataJWS {
    'header'?: AttachDecoratorDataJWSHeader;
    /**
    * protected JWS header
    */
    '_protected'?: string;
    /**
    * signature
    */
    'signature'?: string;
    /**
    * List of signatures
    */
    'signatures'?: Array<AttachDecoratorData1JWS>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "AttachDecoratorDataJWSHeader"
        },
        {
            "name": "_protected",
            "baseName": "protected",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "string"
        },
        {
            "name": "signatures",
            "baseName": "signatures",
            "type": "Array<AttachDecoratorData1JWS>"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecoratorDataJWS.attributeTypeMap;
    }
}

export class AttachDecoratorDataJWSHeader {
    /**
    * Key identifier, in W3C did:key or DID URL format
    */
    'kid': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kid",
            "baseName": "kid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AttachDecoratorDataJWSHeader.attributeTypeMap;
    }
}

export class AttachmentDef {
    /**
    * Attachment identifier
    */
    'id'?: string;
    /**
    * Attachment type
    */
    'type'?: AttachmentDef.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "AttachmentDef.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return AttachmentDef.attributeTypeMap;
    }
}

export namespace AttachmentDef {
    export enum TypeEnum {
        CredentialOffer = <any> 'credential-offer',
        PresentProof = <any> 'present-proof'
    }
}
export class AttributeMimeTypesResult {
    'results'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return AttributeMimeTypesResult.attributeTypeMap;
    }
}

export class BasicMessageModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return BasicMessageModuleResponse.attributeTypeMap;
    }
}

export class ClaimFormat {
    'jwt'?: any;
    'jwtVc'?: any;
    'jwtVp'?: any;
    'ldp'?: any;
    'ldpVc'?: any;
    'ldpVp'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jwt",
            "baseName": "jwt",
            "type": "any"
        },
        {
            "name": "jwtVc",
            "baseName": "jwt_vc",
            "type": "any"
        },
        {
            "name": "jwtVp",
            "baseName": "jwt_vp",
            "type": "any"
        },
        {
            "name": "ldp",
            "baseName": "ldp",
            "type": "any"
        },
        {
            "name": "ldpVc",
            "baseName": "ldp_vc",
            "type": "any"
        },
        {
            "name": "ldpVp",
            "baseName": "ldp_vp",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ClaimFormat.attributeTypeMap;
    }
}

export class ClearPendingRevocationsRequest {
    /**
    * Credential revocation ids by revocation registry id: omit for all, specify null or empty list for all pending per revocation registry
    */
    'purge'?: { [key: string]: Array<string>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purge",
            "baseName": "purge",
            "type": "{ [key: string]: Array<string>; }"
        }    ];

    static getAttributeTypeMap() {
        return ClearPendingRevocationsRequest.attributeTypeMap;
    }
}

export class ConnRecord {
    /**
    * Connection acceptance: manual or auto
    */
    'accept'?: ConnRecord.AcceptEnum;
    /**
    * Optional alias to apply to connection for later use
    */
    'alias'?: string;
    /**
    * Connection identifier
    */
    'connectionId'?: string;
    /**
    * Connection protocol used
    */
    'connectionProtocol'?: ConnRecord.ConnectionProtocolEnum;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Error message
    */
    'errorMsg'?: string;
    /**
    * Inbound routing connection id to use
    */
    'inboundConnectionId'?: string;
    /**
    * Public key for connection
    */
    'invitationKey'?: string;
    /**
    * Invitation mode
    */
    'invitationMode'?: ConnRecord.InvitationModeEnum;
    /**
    * ID of out-of-band invitation message
    */
    'invitationMsgId'?: string;
    /**
    * Our DID for connection
    */
    'myDid'?: string;
    /**
    * Connection request identifier
    */
    'requestId'?: string;
    /**
    * State per RFC 23
    */
    'rfc23State'?: string;
    /**
    * Routing state of connection
    */
    'routingState'?: ConnRecord.RoutingStateEnum;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Their DID for connection
    */
    'theirDid'?: string;
    /**
    * Their label for connection
    */
    'theirLabel'?: string;
    /**
    * Other agent's public DID for connection
    */
    'theirPublicDid'?: string;
    /**
    * Their role in the connection protocol
    */
    'theirRole'?: ConnRecord.TheirRoleEnum;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accept",
            "baseName": "accept",
            "type": "ConnRecord.AcceptEnum"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "connectionProtocol",
            "baseName": "connection_protocol",
            "type": "ConnRecord.ConnectionProtocolEnum"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "errorMsg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "inboundConnectionId",
            "baseName": "inbound_connection_id",
            "type": "string"
        },
        {
            "name": "invitationKey",
            "baseName": "invitation_key",
            "type": "string"
        },
        {
            "name": "invitationMode",
            "baseName": "invitation_mode",
            "type": "ConnRecord.InvitationModeEnum"
        },
        {
            "name": "invitationMsgId",
            "baseName": "invitation_msg_id",
            "type": "string"
        },
        {
            "name": "myDid",
            "baseName": "my_did",
            "type": "string"
        },
        {
            "name": "requestId",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "rfc23State",
            "baseName": "rfc23_state",
            "type": "string"
        },
        {
            "name": "routingState",
            "baseName": "routing_state",
            "type": "ConnRecord.RoutingStateEnum"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "theirDid",
            "baseName": "their_did",
            "type": "string"
        },
        {
            "name": "theirLabel",
            "baseName": "their_label",
            "type": "string"
        },
        {
            "name": "theirPublicDid",
            "baseName": "their_public_did",
            "type": "string"
        },
        {
            "name": "theirRole",
            "baseName": "their_role",
            "type": "ConnRecord.TheirRoleEnum"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConnRecord.attributeTypeMap;
    }
}

export namespace ConnRecord {
    export enum AcceptEnum {
        Manual = <any> 'manual',
        Auto = <any> 'auto'
    }
    export enum ConnectionProtocolEnum {
        Connections10 = <any> 'connections/1.0',
        Didexchange10 = <any> 'didexchange/1.0'
    }
    export enum InvitationModeEnum {
        Once = <any> 'once',
        Multi = <any> 'multi',
        Static = <any> 'static'
    }
    export enum RoutingStateEnum {
        None = <any> 'none',
        Request = <any> 'request',
        Active = <any> 'active',
        Error = <any> 'error'
    }
    export enum TheirRoleEnum {
        Invitee = <any> 'invitee',
        Requester = <any> 'requester',
        Inviter = <any> 'inviter',
        Responder = <any> 'responder'
    }
}
export class ConnectionInvitation {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * DID for connection invitation
    */
    'did'?: string;
    /**
    * Optional image URL for connection invitation
    */
    'imageUrl'?: string;
    /**
    * Optional label for connection invitation
    */
    'label'?: string;
    /**
    * List of recipient keys
    */
    'recipientKeys'?: Array<string>;
    /**
    * List of routing keys
    */
    'routingKeys'?: Array<string>;
    /**
    * Service endpoint at which to reach this agent
    */
    'serviceEndpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "recipientKeys",
            "baseName": "recipientKeys",
            "type": "Array<string>"
        },
        {
            "name": "routingKeys",
            "baseName": "routingKeys",
            "type": "Array<string>"
        },
        {
            "name": "serviceEndpoint",
            "baseName": "serviceEndpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionInvitation.attributeTypeMap;
    }
}

export class ConnectionList {
    /**
    * List of connection records
    */
    'results'?: Array<ConnRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<ConnRecord>"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionList.attributeTypeMap;
    }
}

export class ConnectionMetadata {
    /**
    * Dictionary of metadata associated with connection.
    */
    'results'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionMetadata.attributeTypeMap;
    }
}

export class ConnectionMetadataSetRequest {
    /**
    * Dictionary of metadata to set for connection.
    */
    'metadata': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionMetadataSetRequest.attributeTypeMap;
    }
}

export class ConnectionModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ConnectionModuleResponse.attributeTypeMap;
    }
}

export class ConnectionStaticRequest {
    /**
    * Alias to assign to this connection
    */
    'alias'?: string;
    /**
    * Local DID
    */
    'myDid'?: string;
    /**
    * Seed to use for the local DID
    */
    'mySeed'?: string;
    /**
    * Remote DID
    */
    'theirDid'?: string;
    /**
    * URL endpoint for other party
    */
    'theirEndpoint'?: string;
    /**
    * Other party's label for this connection
    */
    'theirLabel'?: string;
    /**
    * Seed to use for the remote DID
    */
    'theirSeed'?: string;
    /**
    * Remote verification key
    */
    'theirVerkey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "myDid",
            "baseName": "my_did",
            "type": "string"
        },
        {
            "name": "mySeed",
            "baseName": "my_seed",
            "type": "string"
        },
        {
            "name": "theirDid",
            "baseName": "their_did",
            "type": "string"
        },
        {
            "name": "theirEndpoint",
            "baseName": "their_endpoint",
            "type": "string"
        },
        {
            "name": "theirLabel",
            "baseName": "their_label",
            "type": "string"
        },
        {
            "name": "theirSeed",
            "baseName": "their_seed",
            "type": "string"
        },
        {
            "name": "theirVerkey",
            "baseName": "their_verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionStaticRequest.attributeTypeMap;
    }
}

export class ConnectionStaticResult {
    /**
    * Local DID
    */
    'myDid': string;
    /**
    * My URL endpoint
    */
    'myEndpoint': string;
    /**
    * My verification key
    */
    'myVerkey': string;
    'record': ConnRecord;
    /**
    * Remote DID
    */
    'theirDid': string;
    /**
    * Remote verification key
    */
    'theirVerkey': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "myDid",
            "baseName": "my_did",
            "type": "string"
        },
        {
            "name": "myEndpoint",
            "baseName": "my_endpoint",
            "type": "string"
        },
        {
            "name": "myVerkey",
            "baseName": "my_verkey",
            "type": "string"
        },
        {
            "name": "record",
            "baseName": "record",
            "type": "ConnRecord"
        },
        {
            "name": "theirDid",
            "baseName": "their_did",
            "type": "string"
        },
        {
            "name": "theirVerkey",
            "baseName": "their_verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionStaticResult.attributeTypeMap;
    }
}

export class Constraints {
    'fields'?: Array<DIFField>;
    'isHolder'?: Array<DIFHolder>;
    /**
    * LimitDisclosure
    */
    'limitDisclosure'?: string;
    'statusActive'?: Constraints.StatusActiveEnum;
    'statusRevoked'?: Constraints.StatusRevokedEnum;
    'statusSuspended'?: Constraints.StatusSuspendedEnum;
    /**
    * SubjectIsIssuer
    */
    'subjectIsIssuer'?: Constraints.SubjectIsIssuerEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<DIFField>"
        },
        {
            "name": "isHolder",
            "baseName": "is_holder",
            "type": "Array<DIFHolder>"
        },
        {
            "name": "limitDisclosure",
            "baseName": "limit_disclosure",
            "type": "string"
        },
        {
            "name": "statusActive",
            "baseName": "status_active",
            "type": "Constraints.StatusActiveEnum"
        },
        {
            "name": "statusRevoked",
            "baseName": "status_revoked",
            "type": "Constraints.StatusRevokedEnum"
        },
        {
            "name": "statusSuspended",
            "baseName": "status_suspended",
            "type": "Constraints.StatusSuspendedEnum"
        },
        {
            "name": "subjectIsIssuer",
            "baseName": "subject_is_issuer",
            "type": "Constraints.SubjectIsIssuerEnum"
        }    ];

    static getAttributeTypeMap() {
        return Constraints.attributeTypeMap;
    }
}

export namespace Constraints {
    export enum StatusActiveEnum {
        Required = <any> 'required',
        Allowed = <any> 'allowed',
        Disallowed = <any> 'disallowed'
    }
    export enum StatusRevokedEnum {
        Required = <any> 'required',
        Allowed = <any> 'allowed',
        Disallowed = <any> 'disallowed'
    }
    export enum StatusSuspendedEnum {
        Required = <any> 'required',
        Allowed = <any> 'allowed',
        Disallowed = <any> 'disallowed'
    }
    export enum SubjectIsIssuerEnum {
        Required = <any> 'required',
        Preferred = <any> 'preferred'
    }
}
export class CreateInvitationRequest {
    /**
    * Identifier for active mediation record to be used
    */
    'mediationId'?: string;
    /**
    * Optional metadata to attach to the connection created with the invitation
    */
    'metadata'?: any;
    /**
    * Optional label for connection invitation
    */
    'myLabel'?: string;
    /**
    * List of recipient keys
    */
    'recipientKeys'?: Array<string>;
    /**
    * List of routing keys
    */
    'routingKeys'?: Array<string>;
    /**
    * Connection endpoint
    */
    'serviceEndpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mediationId",
            "baseName": "mediation_id",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        },
        {
            "name": "myLabel",
            "baseName": "my_label",
            "type": "string"
        },
        {
            "name": "recipientKeys",
            "baseName": "recipient_keys",
            "type": "Array<string>"
        },
        {
            "name": "routingKeys",
            "baseName": "routing_keys",
            "type": "Array<string>"
        },
        {
            "name": "serviceEndpoint",
            "baseName": "service_endpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateInvitationRequest.attributeTypeMap;
    }
}

export class CredAttrSpec {
    /**
    * MIME type: omit for (null) default
    */
    'mimeType'?: string;
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Attribute value: base64-encode if MIME type is present
    */
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mimeType",
            "baseName": "mime-type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredAttrSpec.attributeTypeMap;
    }
}

export class CredDefValue {
    /**
    * Primary value for credential definition
    */
    'primary'?: any;
    /**
    * Revocation value for credential definition
    */
    'revocation'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "primary",
            "baseName": "primary",
            "type": "any"
        },
        {
            "name": "revocation",
            "baseName": "revocation",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CredDefValue.attributeTypeMap;
    }
}

export class CredDefValuePrimary {
    'n'?: string;
    'r'?: Generated;
    'rctxt'?: string;
    's'?: string;
    'z'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "n",
            "baseName": "n",
            "type": "string"
        },
        {
            "name": "r",
            "baseName": "r",
            "type": "Generated"
        },
        {
            "name": "rctxt",
            "baseName": "rctxt",
            "type": "string"
        },
        {
            "name": "s",
            "baseName": "s",
            "type": "string"
        },
        {
            "name": "z",
            "baseName": "z",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredDefValuePrimary.attributeTypeMap;
    }
}

export class CredDefValueRevocation {
    'g'?: string;
    'gDash'?: string;
    'h'?: string;
    'h0'?: string;
    'h1'?: string;
    'h2'?: string;
    'hCap'?: string;
    'htilde'?: string;
    'pk'?: string;
    'u'?: string;
    'y'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "g",
            "baseName": "g",
            "type": "string"
        },
        {
            "name": "gDash",
            "baseName": "g_dash",
            "type": "string"
        },
        {
            "name": "h",
            "baseName": "h",
            "type": "string"
        },
        {
            "name": "h0",
            "baseName": "h0",
            "type": "string"
        },
        {
            "name": "h1",
            "baseName": "h1",
            "type": "string"
        },
        {
            "name": "h2",
            "baseName": "h2",
            "type": "string"
        },
        {
            "name": "hCap",
            "baseName": "h_cap",
            "type": "string"
        },
        {
            "name": "htilde",
            "baseName": "htilde",
            "type": "string"
        },
        {
            "name": "pk",
            "baseName": "pk",
            "type": "string"
        },
        {
            "name": "u",
            "baseName": "u",
            "type": "string"
        },
        {
            "name": "y",
            "baseName": "y",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredDefValueRevocation.attributeTypeMap;
    }
}

export class CredInfoList {
    'results'?: Array<IndyCredInfo>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<IndyCredInfo>"
        }    ];

    static getAttributeTypeMap() {
        return CredInfoList.attributeTypeMap;
    }
}

export class CredRevRecordResult {
    'result'?: IssuerCredRevRecord;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "IssuerCredRevRecord"
        }    ];

    static getAttributeTypeMap() {
        return CredRevRecordResult.attributeTypeMap;
    }
}

export class CredRevokedResult {
    /**
    * Whether credential is revoked on the ledger
    */
    'revoked'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "revoked",
            "baseName": "revoked",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CredRevokedResult.attributeTypeMap;
    }
}

export class Credential {
    /**
    * The JSON-LD context of the credential
    */
    'context': Array<any>;
    'credentialSubject': any;
    /**
    * The expiration date
    */
    'expirationDate'?: string;
    'id'?: string;
    /**
    * The issuance date
    */
    'issuanceDate': string;
    /**
    * The JSON-LD Verifiable Credential Issuer. Either string of object with id field.
    */
    'issuer': any;
    /**
    * The proof of the credential
    */
    'proof'?: any;
    /**
    * The JSON-LD type of the credential
    */
    'type': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "@context",
            "type": "Array<any>"
        },
        {
            "name": "credentialSubject",
            "baseName": "credentialSubject",
            "type": "any"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "issuanceDate",
            "baseName": "issuanceDate",
            "type": "string"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "any"
        },
        {
            "name": "proof",
            "baseName": "proof",
            "type": "any"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Credential.attributeTypeMap;
    }
}

export class CredentialDefinition {
    /**
    * Credential definition identifier
    */
    'id'?: string;
    /**
    * Schema identifier within credential definition identifier
    */
    'schemaId'?: string;
    /**
    * Tag within credential definition identifier
    */
    'tag'?: string;
    /**
    * Signature type: CL for Camenisch-Lysyanskaya
    */
    'type'?: any;
    /**
    * Credential definition primary and revocation values
    */
    'value'?: any;
    /**
    * Node protocol version
    */
    'ver'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schemaId",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "any"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        },
        {
            "name": "ver",
            "baseName": "ver",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinition.attributeTypeMap;
    }
}

export class CredentialDefinitionGetResult {
    'credentialDefinition'?: CredentialDefinition;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credentialDefinition",
            "baseName": "credential_definition",
            "type": "CredentialDefinition"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinitionGetResult.attributeTypeMap;
    }
}

export class CredentialDefinitionSendRequest {
    /**
    * Revocation registry size
    */
    'revocationRegistrySize'?: number;
    /**
    * Schema identifier
    */
    'schemaId'?: string;
    /**
    * Revocation supported flag
    */
    'supportRevocation'?: boolean;
    /**
    * Credential definition identifier tag
    */
    'tag'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "revocationRegistrySize",
            "baseName": "revocation_registry_size",
            "type": "number"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "supportRevocation",
            "baseName": "support_revocation",
            "type": "boolean"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinitionSendRequest.attributeTypeMap;
    }
}

export class CredentialDefinitionSendResult {
    /**
    * Credential definition identifier
    */
    'credentialDefinitionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credentialDefinitionId",
            "baseName": "credential_definition_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinitionSendResult.attributeTypeMap;
    }
}

export class CredentialDefinitionsCreatedResult {
    'credentialDefinitionIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credentialDefinitionIds",
            "baseName": "credential_definition_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CredentialDefinitionsCreatedResult.attributeTypeMap;
    }
}

export class CredentialOffer {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'credentialPreview'?: CredentialPreview;
    'offersattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credentialPreview",
            "baseName": "credential_preview",
            "type": "CredentialPreview"
        },
        {
            "name": "offersattach",
            "baseName": "offers~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return CredentialOffer.attributeTypeMap;
    }
}

export class CredentialPreview {
    /**
    * Message type identifier
    */
    'type'?: string;
    'attributes': Array<CredAttrSpec>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<CredAttrSpec>"
        }    ];

    static getAttributeTypeMap() {
        return CredentialPreview.attributeTypeMap;
    }
}

export class CredentialProposal {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'credDefId'?: string;
    'credentialProposal'?: CredentialPreview;
    'issuerDid'?: string;
    'schemaId'?: string;
    'schemaIssuerDid'?: string;
    'schemaName'?: string;
    'schemaVersion'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credentialProposal",
            "baseName": "credential_proposal",
            "type": "CredentialPreview"
        },
        {
            "name": "issuerDid",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schemaIssuerDid",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schemaName",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schemaVersion",
            "baseName": "schema_version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialProposal.attributeTypeMap;
    }
}

export class CredentialStatusOptions {
    /**
    * Credential status method type to use for the credential. Should match status method registered in the Verifiable Credential Extension Registry
    */
    'type': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialStatusOptions.attributeTypeMap;
    }
}

export class DID {
    /**
    * DID of interest
    */
    'did'?: string;
    /**
    * Key type associated with the DID
    */
    'keyType'?: DID.KeyTypeEnum;
    /**
    * Did method associated with the DID
    */
    'method'?: DID.MethodEnum;
    /**
    * Whether DID is current public DID, posted to ledger but not current public DID, or local to the wallet
    */
    'posture'?: DID.PostureEnum;
    /**
    * Public verification key
    */
    'verkey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "keyType",
            "baseName": "key_type",
            "type": "DID.KeyTypeEnum"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "DID.MethodEnum"
        },
        {
            "name": "posture",
            "baseName": "posture",
            "type": "DID.PostureEnum"
        },
        {
            "name": "verkey",
            "baseName": "verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DID.attributeTypeMap;
    }
}

export namespace DID {
    export enum KeyTypeEnum {
        Ed25519 = <any> 'ed25519',
        Bls12381g2 = <any> 'bls12381g2'
    }
    export enum MethodEnum {
        Sov = <any> 'sov',
        Key = <any> 'key'
    }
    export enum PostureEnum {
        Public = <any> 'public',
        Posted = <any> 'posted',
        WalletOnly = <any> 'wallet_only'
    }
}
export class DIDCreate {
    'method'?: DIDCreate.MethodEnum;
    /**
    * To define a key type for a did:key
    */
    'options'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "method",
            "baseName": "method",
            "type": "DIDCreate.MethodEnum"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DIDCreate.attributeTypeMap;
    }
}

export namespace DIDCreate {
    export enum MethodEnum {
        Key = <any> 'key',
        Sov = <any> 'sov'
    }
}
export class DIDCreateOptions {
    'keyType': DIDCreateOptions.KeyTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "keyType",
            "baseName": "key_type",
            "type": "DIDCreateOptions.KeyTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return DIDCreateOptions.attributeTypeMap;
    }
}

export namespace DIDCreateOptions {
    export enum KeyTypeEnum {
        Ed25519 = <any> 'ed25519',
        Bls12381g2 = <any> 'bls12381g2'
    }
}
export class DIDEndpoint {
    /**
    * DID of interest
    */
    'did': string;
    /**
    * Endpoint to set (omit to delete)
    */
    'endpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DIDEndpoint.attributeTypeMap;
    }
}

export class DIDEndpointWithType {
    /**
    * DID of interest
    */
    'did': string;
    /**
    * Endpoint to set (omit to delete)
    */
    'endpoint'?: string;
    /**
    * Endpoint type to set (default 'Endpoint'); affects only public or posted DIDs
    */
    'endpointType'?: DIDEndpointWithType.EndpointTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        },
        {
            "name": "endpointType",
            "baseName": "endpoint_type",
            "type": "DIDEndpointWithType.EndpointTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return DIDEndpointWithType.attributeTypeMap;
    }
}

export namespace DIDEndpointWithType {
    export enum EndpointTypeEnum {
        Endpoint = <any> 'Endpoint',
        Profile = <any> 'Profile',
        LinkedDomains = <any> 'LinkedDomains'
    }
}
export class DIDList {
    /**
    * DID list
    */
    'results'?: Array<DID>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<DID>"
        }    ];

    static getAttributeTypeMap() {
        return DIDList.attributeTypeMap;
    }
}

export class DIDResult {
    'result'?: DID;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "DID"
        }    ];

    static getAttributeTypeMap() {
        return DIDResult.attributeTypeMap;
    }
}

export class DIDXRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * DID of exchange
    */
    'did'?: string;
    /**
    * As signed attachment, DID Doc associated with DID
    */
    'didDocattach'?: any;
    /**
    * Label for DID exchange request
    */
    'label': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "didDocattach",
            "baseName": "did_doc~attach",
            "type": "any"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DIDXRequest.attributeTypeMap;
    }
}

export class DIFField {
    'filter'?: Filter;
    /**
    * ID
    */
    'id'?: string;
    'path'?: Array<string>;
    /**
    * Preference
    */
    'predicate'?: DIFField.PredicateEnum;
    /**
    * Purpose
    */
    'purpose'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "Filter"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "Array<string>"
        },
        {
            "name": "predicate",
            "baseName": "predicate",
            "type": "DIFField.PredicateEnum"
        },
        {
            "name": "purpose",
            "baseName": "purpose",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DIFField.attributeTypeMap;
    }
}

export namespace DIFField {
    export enum PredicateEnum {
        Required = <any> 'required',
        Preferred = <any> 'preferred'
    }
}
export class DIFHolder {
    /**
    * Preference
    */
    'directive'?: DIFHolder.DirectiveEnum;
    'fieldId'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "directive",
            "baseName": "directive",
            "type": "DIFHolder.DirectiveEnum"
        },
        {
            "name": "fieldId",
            "baseName": "field_id",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return DIFHolder.attributeTypeMap;
    }
}

export namespace DIFHolder {
    export enum DirectiveEnum {
        Required = <any> 'required',
        Preferred = <any> 'preferred'
    }
}
export class DIFOptions {
    /**
    * Challenge protect against replay attack
    */
    'challenge'?: string;
    /**
    * Domain protect against replay attack
    */
    'domain'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenge",
            "baseName": "challenge",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DIFOptions.attributeTypeMap;
    }
}

export class DIFPresSpec {
    /**
    * Issuer identifier to sign the presentation, if different from current public DID
    */
    'issuerId'?: string;
    'presentationDefinition'?: PresentationDefinition;
    /**
    * Mapping of input_descriptor id to list of stored W3C credential record_id
    */
    'recordIds'?: any;
    /**
    * reveal doc [JSON-LD frame] dict used to derive the credential when selective disclosure is required
    */
    'revealDoc'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "issuerId",
            "baseName": "issuer_id",
            "type": "string"
        },
        {
            "name": "presentationDefinition",
            "baseName": "presentation_definition",
            "type": "PresentationDefinition"
        },
        {
            "name": "recordIds",
            "baseName": "record_ids",
            "type": "any"
        },
        {
            "name": "revealDoc",
            "baseName": "reveal_doc",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DIFPresSpec.attributeTypeMap;
    }
}

export class DIFProofProposal {
    'inputDescriptors'?: Array<InputDescriptors>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "inputDescriptors",
            "baseName": "input_descriptors",
            "type": "Array<InputDescriptors>"
        }    ];

    static getAttributeTypeMap() {
        return DIFProofProposal.attributeTypeMap;
    }
}

export class DIFProofRequest {
    'options'?: DIFOptions;
    'presentationDefinition': PresentationDefinition;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "options",
            "baseName": "options",
            "type": "DIFOptions"
        },
        {
            "name": "presentationDefinition",
            "baseName": "presentation_definition",
            "type": "PresentationDefinition"
        }    ];

    static getAttributeTypeMap() {
        return DIFProofRequest.attributeTypeMap;
    }
}

export class Disclose {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * List of protocol descriptors
    */
    'protocols': Array<ProtocolDescriptor>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "protocols",
            "baseName": "protocols",
            "type": "Array<ProtocolDescriptor>"
        }    ];

    static getAttributeTypeMap() {
        return Disclose.attributeTypeMap;
    }
}

export class Disclosures {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * List of protocol or goal_code descriptors
    */
    'disclosures': Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "disclosures",
            "baseName": "disclosures",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return Disclosures.attributeTypeMap;
    }
}

export class Doc {
    /**
    * Credential to sign
    */
    'credential': any;
    /**
    * Signature options
    */
    'options': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential",
            "baseName": "credential",
            "type": "any"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Doc.attributeTypeMap;
    }
}

export class EndorserInfo {
    /**
    * Endorser DID
    */
    'endorserDid': string;
    /**
    * Endorser Name
    */
    'endorserName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endorserDid",
            "baseName": "endorser_did",
            "type": "string"
        },
        {
            "name": "endorserName",
            "baseName": "endorser_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EndorserInfo.attributeTypeMap;
    }
}

export class EndpointsResult {
    /**
    * My endpoint
    */
    'myEndpoint'?: string;
    /**
    * Their endpoint
    */
    'theirEndpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "myEndpoint",
            "baseName": "my_endpoint",
            "type": "string"
        },
        {
            "name": "theirEndpoint",
            "baseName": "their_endpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EndpointsResult.attributeTypeMap;
    }
}

export class Filter {
    /**
    * Const
    */
    '_const'?: any;
    '_enum'?: Array<any>;
    /**
    * ExclusiveMaximum
    */
    'exclusiveMaximum'?: any;
    /**
    * ExclusiveMinimum
    */
    'exclusiveMinimum'?: any;
    /**
    * Format
    */
    'format'?: string;
    /**
    * Max Length
    */
    'maxLength'?: number;
    /**
    * Maximum
    */
    'maximum'?: any;
    /**
    * Min Length
    */
    'minLength'?: number;
    /**
    * Minimum
    */
    'minimum'?: any;
    /**
    * Not
    */
    'not'?: boolean;
    /**
    * Pattern
    */
    'pattern'?: string;
    /**
    * Type
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_const",
            "baseName": "const",
            "type": "any"
        },
        {
            "name": "_enum",
            "baseName": "enum",
            "type": "Array<any>"
        },
        {
            "name": "exclusiveMaximum",
            "baseName": "exclusiveMaximum",
            "type": "any"
        },
        {
            "name": "exclusiveMinimum",
            "baseName": "exclusiveMinimum",
            "type": "any"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        },
        {
            "name": "maxLength",
            "baseName": "maxLength",
            "type": "number"
        },
        {
            "name": "maximum",
            "baseName": "maximum",
            "type": "any"
        },
        {
            "name": "minLength",
            "baseName": "minLength",
            "type": "number"
        },
        {
            "name": "minimum",
            "baseName": "minimum",
            "type": "any"
        },
        {
            "name": "not",
            "baseName": "not",
            "type": "boolean"
        },
        {
            "name": "pattern",
            "baseName": "pattern",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Filter.attributeTypeMap;
    }
}

export class Generated {
    'masterSecret'?: string;
    'number'?: string;
    'remainder'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "masterSecret",
            "baseName": "master_secret",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "remainder",
            "baseName": "remainder",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Generated.attributeTypeMap;
    }
}

export class GetDIDEndpointResponse {
    /**
    * Full verification key
    */
    'endpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetDIDEndpointResponse.attributeTypeMap;
    }
}

export class GetDIDVerkeyResponse {
    /**
    * Full verification key
    */
    'verkey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "verkey",
            "baseName": "verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetDIDVerkeyResponse.attributeTypeMap;
    }
}

export class GetNymRoleResponse {
    /**
    * Ledger role
    */
    'role'?: GetNymRoleResponse.RoleEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "role",
            "baseName": "role",
            "type": "GetNymRoleResponse.RoleEnum"
        }    ];

    static getAttributeTypeMap() {
        return GetNymRoleResponse.attributeTypeMap;
    }
}

export namespace GetNymRoleResponse {
    export enum RoleEnum {
        STEWARD = <any> 'STEWARD',
        TRUSTEE = <any> 'TRUSTEE',
        ENDORSER = <any> 'ENDORSER',
        NETWORKMONITOR = <any> 'NETWORK_MONITOR',
        USER = <any> 'USER',
        ROLEREMOVE = <any> 'ROLE_REMOVE'
    }
}
export class HolderModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return HolderModuleResponse.attributeTypeMap;
    }
}

export class IndyAttrValue {
    /**
    * Attribute encoded value
    */
    'encoded': string;
    /**
    * Attribute raw value
    */
    'raw': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "encoded",
            "baseName": "encoded",
            "type": "string"
        },
        {
            "name": "raw",
            "baseName": "raw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyAttrValue.attributeTypeMap;
    }
}

export class IndyCredAbstract {
    /**
    * Credential definition identifier
    */
    'credDefId': string;
    /**
    * Key correctness proof
    */
    'keyCorrectnessProof': any;
    /**
    * Nonce in credential abstract
    */
    'nonce': string;
    /**
    * Schema identifier
    */
    'schemaId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "keyCorrectnessProof",
            "baseName": "key_correctness_proof",
            "type": "any"
        },
        {
            "name": "nonce",
            "baseName": "nonce",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredAbstract.attributeTypeMap;
    }
}

export class IndyCredInfo {
    /**
    * Attribute names and value
    */
    'attrs'?: { [key: string]: string; };
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    /**
    * Credential revocation identifier
    */
    'credRevId'?: string;
    /**
    * Wallet referent
    */
    'referent'?: string;
    /**
    * Revocation registry identifier
    */
    'revRegId'?: string;
    /**
    * Schema identifier
    */
    'schemaId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attrs",
            "baseName": "attrs",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credRevId",
            "baseName": "cred_rev_id",
            "type": "string"
        },
        {
            "name": "referent",
            "baseName": "referent",
            "type": "string"
        },
        {
            "name": "revRegId",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredInfo.attributeTypeMap;
    }
}

export class IndyCredPrecis {
    /**
    * Credential info
    */
    'credInfo'?: any;
    /**
    * Non-revocation interval from presentation request
    */
    'interval'?: any;
    'presentationReferents'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credInfo",
            "baseName": "cred_info",
            "type": "any"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "any"
        },
        {
            "name": "presentationReferents",
            "baseName": "presentation_referents",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredPrecis.attributeTypeMap;
    }
}

export class IndyCredRequest {
    /**
    * Blinded master secret
    */
    'blindedMs': any;
    /**
    * Blinded master secret correctness proof
    */
    'blindedMsCorrectnessProof': any;
    /**
    * Credential definition identifier
    */
    'credDefId': string;
    /**
    * Nonce in credential request
    */
    'nonce': string;
    /**
    * Prover DID
    */
    'proverDid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "blindedMs",
            "baseName": "blinded_ms",
            "type": "any"
        },
        {
            "name": "blindedMsCorrectnessProof",
            "baseName": "blinded_ms_correctness_proof",
            "type": "any"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "nonce",
            "baseName": "nonce",
            "type": "string"
        },
        {
            "name": "proverDid",
            "baseName": "prover_did",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredRequest.attributeTypeMap;
    }
}

export class IndyCredential {
    /**
    * Credential definition identifier
    */
    'credDefId': string;
    /**
    * Revocation registry state
    */
    'revReg'?: any;
    /**
    * Revocation registry identifier
    */
    'revRegId'?: string;
    /**
    * Schema identifier
    */
    'schemaId': string;
    /**
    * Credential signature
    */
    'signature': any;
    /**
    * Credential signature correctness proof
    */
    'signatureCorrectnessProof': any;
    /**
    * Credential attributes
    */
    'values': { [key: string]: any; };
    /**
    * Witness for revocation proof
    */
    'witness'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "revReg",
            "baseName": "rev_reg",
            "type": "any"
        },
        {
            "name": "revRegId",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "any"
        },
        {
            "name": "signatureCorrectnessProof",
            "baseName": "signature_correctness_proof",
            "type": "any"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "witness",
            "baseName": "witness",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return IndyCredential.attributeTypeMap;
    }
}

export class IndyEQProof {
    'aPrime'?: string;
    'e'?: string;
    'm'?: { [key: string]: string; };
    'm2'?: string;
    'revealedAttrs'?: { [key: string]: string; };
    'v'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aPrime",
            "baseName": "a_prime",
            "type": "string"
        },
        {
            "name": "e",
            "baseName": "e",
            "type": "string"
        },
        {
            "name": "m",
            "baseName": "m",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "m2",
            "baseName": "m2",
            "type": "string"
        },
        {
            "name": "revealedAttrs",
            "baseName": "revealed_attrs",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyEQProof.attributeTypeMap;
    }
}

export class IndyGEProof {
    'alpha'?: string;
    'mj'?: string;
    'predicate'?: IndyGEProofPred;
    'r'?: { [key: string]: string; };
    't'?: { [key: string]: string; };
    'u'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alpha",
            "baseName": "alpha",
            "type": "string"
        },
        {
            "name": "mj",
            "baseName": "mj",
            "type": "string"
        },
        {
            "name": "predicate",
            "baseName": "predicate",
            "type": "IndyGEProofPred"
        },
        {
            "name": "r",
            "baseName": "r",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "t",
            "baseName": "t",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "u",
            "baseName": "u",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return IndyGEProof.attributeTypeMap;
    }
}

export class IndyGEProofPred {
    /**
    * Attribute name, indy-canonicalized
    */
    'attrName'?: string;
    /**
    * Predicate type
    */
    'pType'?: IndyGEProofPred.PTypeEnum;
    /**
    * Predicate threshold value
    */
    'value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attrName",
            "baseName": "attr_name",
            "type": "string"
        },
        {
            "name": "pType",
            "baseName": "p_type",
            "type": "IndyGEProofPred.PTypeEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyGEProofPred.attributeTypeMap;
    }
}

export namespace IndyGEProofPred {
    export enum PTypeEnum {
        LT = <any> 'LT',
        LE = <any> 'LE',
        GE = <any> 'GE',
        GT = <any> 'GT'
    }
}
export class IndyKeyCorrectnessProof {
    /**
    * c in key correctness proof
    */
    'c': string;
    /**
    * xr_cap in key correctness proof
    */
    'xrCap': Array<Array<string>>;
    /**
    * xz_cap in key correctness proof
    */
    'xzCap': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "c",
            "baseName": "c",
            "type": "string"
        },
        {
            "name": "xrCap",
            "baseName": "xr_cap",
            "type": "Array<Array<string>>"
        },
        {
            "name": "xzCap",
            "baseName": "xz_cap",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyKeyCorrectnessProof.attributeTypeMap;
    }
}

export class IndyNonRevocProof {
    'cList'?: { [key: string]: string; };
    'xList'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cList",
            "baseName": "c_list",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "xList",
            "baseName": "x_list",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return IndyNonRevocProof.attributeTypeMap;
    }
}

export class IndyNonRevocationInterval {
    /**
    * Earliest time of interest in non-revocation interval
    */
    'from'?: number;
    /**
    * Latest time of interest in non-revocation interval
    */
    'to'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyNonRevocationInterval.attributeTypeMap;
    }
}

export class IndyPresAttrSpec {
    'credDefId'?: string;
    /**
    * MIME type (default null)
    */
    'mimeType'?: string;
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Credential referent
    */
    'referent'?: string;
    /**
    * Attribute value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "mimeType",
            "baseName": "mime-type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "referent",
            "baseName": "referent",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyPresAttrSpec.attributeTypeMap;
    }
}

export class IndyPresPredSpec {
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Predicate type ('<', '<=', '>=', or '>')
    */
    'predicate': IndyPresPredSpec.PredicateEnum;
    /**
    * Threshold value
    */
    'threshold': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "predicate",
            "baseName": "predicate",
            "type": "IndyPresPredSpec.PredicateEnum"
        },
        {
            "name": "threshold",
            "baseName": "threshold",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyPresPredSpec.attributeTypeMap;
    }
}

export namespace IndyPresPredSpec {
    export enum PredicateEnum {
        LessThan = <any> '<',
        LessThanOrEqualTo = <any> '<=',
        GreaterThanOrEqualTo = <any> '>=',
        GreaterThan = <any> '>'
    }
}
export class IndyPresPreview {
    /**
    * Message type identifier
    */
    'type'?: string;
    'attributes': Array<IndyPresAttrSpec>;
    'predicates': Array<IndyPresPredSpec>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<IndyPresAttrSpec>"
        },
        {
            "name": "predicates",
            "baseName": "predicates",
            "type": "Array<IndyPresPredSpec>"
        }    ];

    static getAttributeTypeMap() {
        return IndyPresPreview.attributeTypeMap;
    }
}

export class IndyPresSpec {
    /**
    * Nested object mapping proof request attribute referents to requested-attribute specifiers
    */
    'requestedAttributes': { [key: string]: IndyRequestedCredsRequestedAttr; };
    /**
    * Nested object mapping proof request predicate referents to requested-predicate specifiers
    */
    'requestedPredicates': { [key: string]: IndyRequestedCredsRequestedPred; };
    /**
    * Self-attested attributes to build into proof
    */
    'selfAttestedAttributes': { [key: string]: string; };
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestedAttributes",
            "baseName": "requested_attributes",
            "type": "{ [key: string]: IndyRequestedCredsRequestedAttr; }"
        },
        {
            "name": "requestedPredicates",
            "baseName": "requested_predicates",
            "type": "{ [key: string]: IndyRequestedCredsRequestedPred; }"
        },
        {
            "name": "selfAttestedAttributes",
            "baseName": "self_attested_attributes",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndyPresSpec.attributeTypeMap;
    }
}

export class IndyPrimaryProof {
    /**
    * Indy equality proof
    */
    'eqProof'?: any;
    /**
    * Indy GE proofs
    */
    'geProofs'?: Array<IndyGEProof>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eqProof",
            "baseName": "eq_proof",
            "type": "any"
        },
        {
            "name": "geProofs",
            "baseName": "ge_proofs",
            "type": "Array<IndyGEProof>"
        }    ];

    static getAttributeTypeMap() {
        return IndyPrimaryProof.attributeTypeMap;
    }
}

export class IndyProof {
    /**
    * Indy proof.identifiers content
    */
    'identifiers'?: Array<IndyProofIdentifier>;
    /**
    * Indy proof.proof content
    */
    'proof'?: any;
    /**
    * Indy proof.requested_proof content
    */
    'requestedProof'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifiers",
            "baseName": "identifiers",
            "type": "Array<IndyProofIdentifier>"
        },
        {
            "name": "proof",
            "baseName": "proof",
            "type": "any"
        },
        {
            "name": "requestedProof",
            "baseName": "requested_proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return IndyProof.attributeTypeMap;
    }
}

export class IndyProofIdentifier {
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    /**
    * Revocation registry identifier
    */
    'revRegId'?: string;
    /**
    * Schema identifier
    */
    'schemaId'?: string;
    /**
    * Timestamp epoch
    */
    'timestamp'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "revRegId",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofIdentifier.attributeTypeMap;
    }
}

export class IndyProofProof {
    /**
    * Indy proof aggregated proof
    */
    'aggregatedProof'?: any;
    /**
    * Indy proof proofs
    */
    'proofs'?: Array<IndyProofProofProofsProof>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aggregatedProof",
            "baseName": "aggregated_proof",
            "type": "any"
        },
        {
            "name": "proofs",
            "baseName": "proofs",
            "type": "Array<IndyProofProofProofsProof>"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofProof.attributeTypeMap;
    }
}

export class IndyProofProofAggregatedProof {
    /**
    * c_hash value
    */
    'cHash'?: string;
    /**
    * c_list value
    */
    'cList'?: Array<Array<number>>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cHash",
            "baseName": "c_hash",
            "type": "string"
        },
        {
            "name": "cList",
            "baseName": "c_list",
            "type": "Array<Array<number>>"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofProofAggregatedProof.attributeTypeMap;
    }
}

export class IndyProofProofProofsProof {
    /**
    * Indy non-revocation proof
    */
    'nonRevocProof'?: any;
    /**
    * Indy primary proof
    */
    'primaryProof'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nonRevocProof",
            "baseName": "non_revoc_proof",
            "type": "any"
        },
        {
            "name": "primaryProof",
            "baseName": "primary_proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofProofProofsProof.attributeTypeMap;
    }
}

export class IndyProofReqAttrSpec {
    /**
    * Attribute name
    */
    'name'?: string;
    /**
    * Attribute name group
    */
    'names'?: Array<string>;
    'nonRevoked'?: any;
    /**
    * If present, credential must satisfy one of given restrictions: specify schema_id, schema_issuer_did, schema_name, schema_version, issuer_did, cred_def_id, and/or attr::<attribute-name>::value where <attribute-name> represents a credential attribute name
    */
    'restrictions'?: Array<{ [key: string]: string; }>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "names",
            "baseName": "names",
            "type": "Array<string>"
        },
        {
            "name": "nonRevoked",
            "baseName": "non_revoked",
            "type": "any"
        },
        {
            "name": "restrictions",
            "baseName": "restrictions",
            "type": "Array<{ [key: string]: string; }>"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofReqAttrSpec.attributeTypeMap;
    }
}

export class IndyProofReqAttrSpecNonRevoked {
    /**
    * Earliest time of interest in non-revocation interval
    */
    'from'?: number;
    /**
    * Latest time of interest in non-revocation interval
    */
    'to'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofReqAttrSpecNonRevoked.attributeTypeMap;
    }
}

export class IndyProofReqPredSpec {
    /**
    * Attribute name
    */
    'name': string;
    'nonRevoked'?: any;
    /**
    * Predicate type ('<', '<=', '>=', or '>')
    */
    'pType': IndyProofReqPredSpec.PTypeEnum;
    /**
    * Threshold value
    */
    'pValue': number;
    /**
    * If present, credential must satisfy one of given restrictions: specify schema_id, schema_issuer_did, schema_name, schema_version, issuer_did, cred_def_id, and/or attr::<attribute-name>::value where <attribute-name> represents a credential attribute name
    */
    'restrictions'?: Array<{ [key: string]: string; }>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nonRevoked",
            "baseName": "non_revoked",
            "type": "any"
        },
        {
            "name": "pType",
            "baseName": "p_type",
            "type": "IndyProofReqPredSpec.PTypeEnum"
        },
        {
            "name": "pValue",
            "baseName": "p_value",
            "type": "number"
        },
        {
            "name": "restrictions",
            "baseName": "restrictions",
            "type": "Array<{ [key: string]: string; }>"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofReqPredSpec.attributeTypeMap;
    }
}

export namespace IndyProofReqPredSpec {
    export enum PTypeEnum {
        LessThan = <any> '<',
        LessThanOrEqualTo = <any> '<=',
        GreaterThanOrEqualTo = <any> '>=',
        GreaterThan = <any> '>'
    }
}
export class IndyProofReqPredSpecNonRevoked {
    /**
    * Earliest time of interest in non-revocation interval
    */
    'from'?: number;
    /**
    * Latest time of interest in non-revocation interval
    */
    'to'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofReqPredSpecNonRevoked.attributeTypeMap;
    }
}

export class IndyProofRequest {
    /**
    * Proof request name
    */
    'name'?: string;
    'nonRevoked'?: any;
    /**
    * Nonce
    */
    'nonce'?: string;
    /**
    * Requested attribute specifications of proof request
    */
    'requestedAttributes': { [key: string]: IndyProofReqAttrSpec; };
    /**
    * Requested predicate specifications of proof request
    */
    'requestedPredicates': { [key: string]: IndyProofReqPredSpec; };
    /**
    * Proof request version
    */
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nonRevoked",
            "baseName": "non_revoked",
            "type": "any"
        },
        {
            "name": "nonce",
            "baseName": "nonce",
            "type": "string"
        },
        {
            "name": "requestedAttributes",
            "baseName": "requested_attributes",
            "type": "{ [key: string]: IndyProofReqAttrSpec; }"
        },
        {
            "name": "requestedPredicates",
            "baseName": "requested_predicates",
            "type": "{ [key: string]: IndyProofReqPredSpec; }"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequest.attributeTypeMap;
    }
}

export class IndyProofRequestNonRevoked {
    /**
    * Earliest time of interest in non-revocation interval
    */
    'from'?: number;
    /**
    * Latest time of interest in non-revocation interval
    */
    'to'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "number"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestNonRevoked.attributeTypeMap;
    }
}

export class IndyProofRequestedProof {
    /**
    * Proof requested proof predicates.
    */
    'predicates'?: { [key: string]: IndyProofRequestedProofPredicate; };
    /**
    * Proof requested proof revealed attribute groups
    */
    'revealedAttrGroups'?: { [key: string]: IndyProofRequestedProofRevealedAttrGroup; };
    /**
    * Proof requested proof revealed attributes
    */
    'revealedAttrs'?: { [key: string]: IndyProofRequestedProofRevealedAttr; };
    /**
    * Proof requested proof self-attested attributes
    */
    'selfAttestedAttrs'?: any;
    /**
    * Unrevealed attributes
    */
    'unrevealedAttrs'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "predicates",
            "baseName": "predicates",
            "type": "{ [key: string]: IndyProofRequestedProofPredicate; }"
        },
        {
            "name": "revealedAttrGroups",
            "baseName": "revealed_attr_groups",
            "type": "{ [key: string]: IndyProofRequestedProofRevealedAttrGroup; }"
        },
        {
            "name": "revealedAttrs",
            "baseName": "revealed_attrs",
            "type": "{ [key: string]: IndyProofRequestedProofRevealedAttr; }"
        },
        {
            "name": "selfAttestedAttrs",
            "baseName": "self_attested_attrs",
            "type": "any"
        },
        {
            "name": "unrevealedAttrs",
            "baseName": "unrevealed_attrs",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestedProof.attributeTypeMap;
    }
}

export class IndyProofRequestedProofPredicate {
    /**
    * Sub-proof index
    */
    'subProofIndex'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subProofIndex",
            "baseName": "sub_proof_index",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestedProofPredicate.attributeTypeMap;
    }
}

export class IndyProofRequestedProofRevealedAttr {
    /**
    * Encoded value
    */
    'encoded'?: string;
    /**
    * Raw value
    */
    'raw'?: string;
    /**
    * Sub-proof index
    */
    'subProofIndex'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "encoded",
            "baseName": "encoded",
            "type": "string"
        },
        {
            "name": "raw",
            "baseName": "raw",
            "type": "string"
        },
        {
            "name": "subProofIndex",
            "baseName": "sub_proof_index",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestedProofRevealedAttr.attributeTypeMap;
    }
}

export class IndyProofRequestedProofRevealedAttrGroup {
    /**
    * Sub-proof index
    */
    'subProofIndex'?: number;
    /**
    * Indy proof requested proof revealed attr groups group value
    */
    'values'?: { [key: string]: RawEncoded; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subProofIndex",
            "baseName": "sub_proof_index",
            "type": "number"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "{ [key: string]: RawEncoded; }"
        }    ];

    static getAttributeTypeMap() {
        return IndyProofRequestedProofRevealedAttrGroup.attributeTypeMap;
    }
}

export class IndyRequestedCredsRequestedAttr {
    /**
    * Wallet credential identifier (typically but not necessarily a UUID)
    */
    'credId': string;
    /**
    * Whether to reveal attribute in proof (default true)
    */
    'revealed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credId",
            "baseName": "cred_id",
            "type": "string"
        },
        {
            "name": "revealed",
            "baseName": "revealed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return IndyRequestedCredsRequestedAttr.attributeTypeMap;
    }
}

export class IndyRequestedCredsRequestedPred {
    /**
    * Wallet credential identifier (typically but not necessarily a UUID)
    */
    'credId': string;
    /**
    * Epoch timestamp of interest for non-revocation proof
    */
    'timestamp'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credId",
            "baseName": "cred_id",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IndyRequestedCredsRequestedPred.attributeTypeMap;
    }
}

export class IndyRevRegDef {
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    /**
    * Indy revocation registry identifier
    */
    'id'?: string;
    /**
    * Revocation registry type (specify CL_ACCUM)
    */
    'revocDefType'?: IndyRevRegDef.RevocDefTypeEnum;
    /**
    * Revocation registry tag
    */
    'tag'?: string;
    /**
    * Revocation registry definition value
    */
    'value'?: any;
    /**
    * Version of revocation registry definition
    */
    'ver'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credDefId",
            "baseName": "credDefId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "revocDefType",
            "baseName": "revocDefType",
            "type": "IndyRevRegDef.RevocDefTypeEnum"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        },
        {
            "name": "ver",
            "baseName": "ver",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegDef.attributeTypeMap;
    }
}

export namespace IndyRevRegDef {
    export enum RevocDefTypeEnum {
        CLACCUM = <any> 'CL_ACCUM'
    }
}
export class IndyRevRegDefValue {
    /**
    * Issuance type
    */
    'issuanceType'?: IndyRevRegDefValue.IssuanceTypeEnum;
    /**
    * Maximum number of credentials; registry size
    */
    'maxCredNum'?: number;
    /**
    * Public keys
    */
    'publicKeys'?: any;
    /**
    * Tails hash value
    */
    'tailsHash'?: string;
    /**
    * Tails file location
    */
    'tailsLocation'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "issuanceType",
            "baseName": "issuanceType",
            "type": "IndyRevRegDefValue.IssuanceTypeEnum"
        },
        {
            "name": "maxCredNum",
            "baseName": "maxCredNum",
            "type": "number"
        },
        {
            "name": "publicKeys",
            "baseName": "publicKeys",
            "type": "any"
        },
        {
            "name": "tailsHash",
            "baseName": "tailsHash",
            "type": "string"
        },
        {
            "name": "tailsLocation",
            "baseName": "tailsLocation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegDefValue.attributeTypeMap;
    }
}

export namespace IndyRevRegDefValue {
    export enum IssuanceTypeEnum {
        ONDEMAND = <any> 'ISSUANCE_ON_DEMAND',
        BYDEFAULT = <any> 'ISSUANCE_BY_DEFAULT'
    }
}
export class IndyRevRegDefValuePublicKeys {
    'accumKey'?: IndyRevRegDefValuePublicKeysAccumKey;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accumKey",
            "baseName": "accumKey",
            "type": "IndyRevRegDefValuePublicKeysAccumKey"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegDefValuePublicKeys.attributeTypeMap;
    }
}

export class IndyRevRegDefValuePublicKeysAccumKey {
    /**
    * Value for z
    */
    'z'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "z",
            "baseName": "z",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegDefValuePublicKeysAccumKey.attributeTypeMap;
    }
}

export class IndyRevRegEntry {
    /**
    * Revocation registry entry value
    */
    'value'?: any;
    /**
    * Version of revocation registry entry
    */
    'ver'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        },
        {
            "name": "ver",
            "baseName": "ver",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegEntry.attributeTypeMap;
    }
}

export class IndyRevRegEntryValue {
    /**
    * Accumulator value
    */
    'accum'?: string;
    /**
    * Previous accumulator value
    */
    'prevAccum'?: string;
    /**
    * Revoked credential revocation identifiers
    */
    'revoked'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accum",
            "baseName": "accum",
            "type": "string"
        },
        {
            "name": "prevAccum",
            "baseName": "prevAccum",
            "type": "string"
        },
        {
            "name": "revoked",
            "baseName": "revoked",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return IndyRevRegEntryValue.attributeTypeMap;
    }
}

export class InputDescriptors {
    'constraints'?: Constraints;
    'group'?: Array<string>;
    /**
    * ID
    */
    'id'?: string;
    /**
    * Metadata dictionary
    */
    'metadata'?: any;
    /**
    * Name
    */
    'name'?: string;
    /**
    * Purpose
    */
    'purpose'?: string;
    /**
    * Accepts a list of schema or a dict containing filters like oneof_filter.
    */
    'schema'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "constraints",
            "baseName": "constraints",
            "type": "Constraints"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "Array<string>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "purpose",
            "baseName": "purpose",
            "type": "string"
        },
        {
            "name": "schema",
            "baseName": "schema",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InputDescriptors.attributeTypeMap;
    }
}

export class IntroModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return IntroModuleResponse.attributeTypeMap;
    }
}

export class InvitationCreateRequest {
    /**
    * Alias for connection
    */
    'alias'?: string;
    /**
    * Optional invitation attachments
    */
    'attachments'?: Array<AttachmentDef>;
    'handshakeProtocols'?: Array<string>;
    /**
    * Identifier for active mediation record to be used
    */
    'mediationId'?: string;
    /**
    * Optional metadata to attach to the connection created with the invitation
    */
    'metadata'?: any;
    /**
    * Label for connection invitation
    */
    'myLabel'?: string;
    /**
    * Whether to use public DID in invitation
    */
    'usePublicDid'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "attachments",
            "baseName": "attachments",
            "type": "Array<AttachmentDef>"
        },
        {
            "name": "handshakeProtocols",
            "baseName": "handshake_protocols",
            "type": "Array<string>"
        },
        {
            "name": "mediationId",
            "baseName": "mediation_id",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        },
        {
            "name": "myLabel",
            "baseName": "my_label",
            "type": "string"
        },
        {
            "name": "usePublicDid",
            "baseName": "use_public_did",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InvitationCreateRequest.attributeTypeMap;
    }
}

export class InvitationMessage {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    'handshakeProtocols'?: Array<string>;
    /**
    * Optional label
    */
    'label'?: string;
    /**
    * Optional request attachment
    */
    'requestsattach'?: Array<AttachDecorator>;
    'services'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "handshakeProtocols",
            "baseName": "handshake_protocols",
            "type": "Array<string>"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "requestsattach",
            "baseName": "requests~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "services",
            "baseName": "services",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return InvitationMessage.attributeTypeMap;
    }
}

export class InvitationRecord {
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Invitation message identifier
    */
    'inviMsgId'?: string;
    /**
    * Out of band invitation message
    */
    'invitation'?: any;
    /**
    * Invitation record identifier
    */
    'invitationId'?: string;
    /**
    * Invitation message URL
    */
    'invitationUrl'?: string;
    /**
    * Out of band message exchange state
    */
    'state'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "inviMsgId",
            "baseName": "invi_msg_id",
            "type": "string"
        },
        {
            "name": "invitation",
            "baseName": "invitation",
            "type": "any"
        },
        {
            "name": "invitationId",
            "baseName": "invitation_id",
            "type": "string"
        },
        {
            "name": "invitationUrl",
            "baseName": "invitation_url",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvitationRecord.attributeTypeMap;
    }
}

export class InvitationResult {
    /**
    * Connection identifier
    */
    'connectionId'?: string;
    'invitation'?: ConnectionInvitation;
    /**
    * Invitation URL
    */
    'invitationUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "invitation",
            "baseName": "invitation",
            "type": "ConnectionInvitation"
        },
        {
            "name": "invitationUrl",
            "baseName": "invitation_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvitationResult.attributeTypeMap;
    }
}

export class IssueCredentialModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return IssueCredentialModuleResponse.attributeTypeMap;
    }
}

export class IssuerCredRevRecord {
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    /**
    * Credential exchange record identifier at credential issue
    */
    'credExId'?: string;
    /**
    * Credential revocation identifier
    */
    'credRevId'?: string;
    /**
    * Issuer credential revocation record identifier
    */
    'recordId'?: string;
    /**
    * Revocation registry identifier
    */
    'revRegId'?: string;
    /**
    * Issue credential revocation record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credExId",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "credRevId",
            "baseName": "cred_rev_id",
            "type": "string"
        },
        {
            "name": "recordId",
            "baseName": "record_id",
            "type": "string"
        },
        {
            "name": "revRegId",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssuerCredRevRecord.attributeTypeMap;
    }
}

export class IssuerRevRegRecord {
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    /**
    * Error message
    */
    'errorMsg'?: string;
    /**
    * Issuer DID
    */
    'issuerDid'?: string;
    /**
    * Maximum number of credentials for revocation registry
    */
    'maxCredNum'?: number;
    /**
    * Credential revocation identifier for credential revoked and pending publication to ledger
    */
    'pendingPub'?: Array<string>;
    /**
    * Issuer revocation registry record identifier
    */
    'recordId'?: string;
    /**
    * Revocation registry type (specify CL_ACCUM)
    */
    'revocDefType'?: IssuerRevRegRecord.RevocDefTypeEnum;
    /**
    * Revocation registry definition
    */
    'revocRegDef'?: any;
    /**
    * Revocation registry entry
    */
    'revocRegEntry'?: any;
    /**
    * Revocation registry identifier
    */
    'revocRegId'?: string;
    /**
    * Issue revocation registry record state
    */
    'state'?: string;
    /**
    * Tag within issuer revocation registry identifier
    */
    'tag'?: string;
    /**
    * Tails hash
    */
    'tailsHash'?: string;
    /**
    * Local path to tails file
    */
    'tailsLocalPath'?: string;
    /**
    * Public URI for tails file
    */
    'tailsPublicUri'?: string;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "errorMsg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "issuerDid",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "maxCredNum",
            "baseName": "max_cred_num",
            "type": "number"
        },
        {
            "name": "pendingPub",
            "baseName": "pending_pub",
            "type": "Array<string>"
        },
        {
            "name": "recordId",
            "baseName": "record_id",
            "type": "string"
        },
        {
            "name": "revocDefType",
            "baseName": "revoc_def_type",
            "type": "IssuerRevRegRecord.RevocDefTypeEnum"
        },
        {
            "name": "revocRegDef",
            "baseName": "revoc_reg_def",
            "type": "any"
        },
        {
            "name": "revocRegEntry",
            "baseName": "revoc_reg_entry",
            "type": "any"
        },
        {
            "name": "revocRegId",
            "baseName": "revoc_reg_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "tailsHash",
            "baseName": "tails_hash",
            "type": "string"
        },
        {
            "name": "tailsLocalPath",
            "baseName": "tails_local_path",
            "type": "string"
        },
        {
            "name": "tailsPublicUri",
            "baseName": "tails_public_uri",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssuerRevRegRecord.attributeTypeMap;
    }
}

export namespace IssuerRevRegRecord {
    export enum RevocDefTypeEnum {
        CLACCUM = <any> 'CL_ACCUM'
    }
}
export class Keylist {
    /**
    * List of keylist records
    */
    'results'?: Array<RouteRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<RouteRecord>"
        }    ];

    static getAttributeTypeMap() {
        return Keylist.attributeTypeMap;
    }
}

export class KeylistQuery {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Query dictionary object
    */
    'filter'?: any;
    /**
    * Pagination info
    */
    'paginate'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "paginate",
            "baseName": "paginate",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return KeylistQuery.attributeTypeMap;
    }
}

export class KeylistQueryFilterRequest {
    /**
    * Filter for keylist query
    */
    'filter'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return KeylistQueryFilterRequest.attributeTypeMap;
    }
}

export class KeylistQueryPaginate {
    /**
    * Limit for keylist query
    */
    'limit'?: number;
    /**
    * Offset value for query
    */
    'offset'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return KeylistQueryPaginate.attributeTypeMap;
    }
}

export class KeylistUpdate {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * List of update rules
    */
    'updates'?: Array<KeylistUpdateRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "updates",
            "baseName": "updates",
            "type": "Array<KeylistUpdateRule>"
        }    ];

    static getAttributeTypeMap() {
        return KeylistUpdate.attributeTypeMap;
    }
}

export class KeylistUpdateRequest {
    'updates'?: Array<KeylistUpdateRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "updates",
            "baseName": "updates",
            "type": "Array<KeylistUpdateRule>"
        }    ];

    static getAttributeTypeMap() {
        return KeylistUpdateRequest.attributeTypeMap;
    }
}

export class KeylistUpdateRule {
    /**
    * Action for specific key
    */
    'action': KeylistUpdateRule.ActionEnum;
    /**
    * Key to remove or add
    */
    'recipientKey': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "action",
            "baseName": "action",
            "type": "KeylistUpdateRule.ActionEnum"
        },
        {
            "name": "recipientKey",
            "baseName": "recipient_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KeylistUpdateRule.attributeTypeMap;
    }
}

export namespace KeylistUpdateRule {
    export enum ActionEnum {
        Add = <any> 'add',
        Remove = <any> 'remove'
    }
}
export class LDProofVCDetail {
    /**
    * Detail of the JSON-LD Credential to be issued
    */
    'credential': any;
    /**
    * Options for specifying how the linked data proof is created.
    */
    'options': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credential",
            "baseName": "credential",
            "type": "any"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return LDProofVCDetail.attributeTypeMap;
    }
}

export class LDProofVCDetailOptions {
    /**
    * A challenge to include in the proof. SHOULD be provided by the requesting party of the credential (=holder)
    */
    'challenge'?: string;
    /**
    * The date and time of the proof (with a maximum accuracy in seconds). Defaults to current system time
    */
    'created'?: string;
    /**
    * The credential status mechanism to use for the credential. Omitting the property indicates the issued credential will not include a credential status
    */
    'credentialStatus'?: any;
    /**
    * The intended domain of validity for the proof
    */
    'domain'?: string;
    /**
    * The proof purpose used for the proof. Should match proof purposes registered in the Linked Data Proofs Specification
    */
    'proofPurpose'?: string;
    /**
    * The proof type used for the proof. Should match suites registered in the Linked Data Cryptographic Suite Registry
    */
    'proofType': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenge",
            "baseName": "challenge",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "credentialStatus",
            "baseName": "credentialStatus",
            "type": "any"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "proofPurpose",
            "baseName": "proofPurpose",
            "type": "string"
        },
        {
            "name": "proofType",
            "baseName": "proofType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LDProofVCDetailOptions.attributeTypeMap;
    }
}

export class LedgerConfigInstance {
    /**
    * genesis_file
    */
    'genesisFile'?: string;
    /**
    * genesis_transactions
    */
    'genesisTransactions'?: string;
    /**
    * genesis_url
    */
    'genesisUrl'?: string;
    /**
    * ledger_id
    */
    'id'?: string;
    /**
    * is_production
    */
    'isProduction'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "genesisFile",
            "baseName": "genesis_file",
            "type": "string"
        },
        {
            "name": "genesisTransactions",
            "baseName": "genesis_transactions",
            "type": "string"
        },
        {
            "name": "genesisUrl",
            "baseName": "genesis_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isProduction",
            "baseName": "is_production",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LedgerConfigInstance.attributeTypeMap;
    }
}

export class LedgerConfigList {
    'ledgerConfigList': Array<LedgerConfigInstance>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ledgerConfigList",
            "baseName": "ledger_config_list",
            "type": "Array<LedgerConfigInstance>"
        }    ];

    static getAttributeTypeMap() {
        return LedgerConfigList.attributeTypeMap;
    }
}

export class LedgerModulesResult {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LedgerModulesResult.attributeTypeMap;
    }
}

export class LinkedDataProof {
    /**
    * Associates a challenge with a proof, for use with a proofPurpose such as authentication
    */
    'challenge'?: string;
    /**
    * The string value of an ISO8601 combined date and time string generated by the Signature Algorithm
    */
    'created': string;
    /**
    * A string value specifying the restricted domain of the signature.
    */
    'domain'?: string;
    /**
    * Associates a Detached Json Web Signature with a proof
    */
    'jws'?: string;
    /**
    * The nonce
    */
    'nonce'?: string;
    /**
    * Proof purpose
    */
    'proofPurpose': string;
    /**
    * The proof value of a proof
    */
    'proofValue'?: string;
    /**
    * Identifies the digital signature suite that was used to create the signature
    */
    'type': string;
    /**
    * Information used for proof verification
    */
    'verificationMethod': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenge",
            "baseName": "challenge",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "jws",
            "baseName": "jws",
            "type": "string"
        },
        {
            "name": "nonce",
            "baseName": "nonce",
            "type": "string"
        },
        {
            "name": "proofPurpose",
            "baseName": "proofPurpose",
            "type": "string"
        },
        {
            "name": "proofValue",
            "baseName": "proofValue",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "verificationMethod",
            "baseName": "verificationMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LinkedDataProof.attributeTypeMap;
    }
}

export class MediationCreateRequest {
    /**
    * List of mediator rules for recipient
    */
    'mediatorTerms'?: Array<string>;
    /**
    * List of recipient rules for mediation
    */
    'recipientTerms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mediatorTerms",
            "baseName": "mediator_terms",
            "type": "Array<string>"
        },
        {
            "name": "recipientTerms",
            "baseName": "recipient_terms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MediationCreateRequest.attributeTypeMap;
    }
}

export class MediationDeny {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    'mediatorTerms'?: Array<string>;
    'recipientTerms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "mediatorTerms",
            "baseName": "mediator_terms",
            "type": "Array<string>"
        },
        {
            "name": "recipientTerms",
            "baseName": "recipient_terms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MediationDeny.attributeTypeMap;
    }
}

export class MediationGrant {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * endpoint on which messages destined for the recipient are received.
    */
    'endpoint'?: string;
    'routingKeys'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        },
        {
            "name": "routingKeys",
            "baseName": "routing_keys",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MediationGrant.attributeTypeMap;
    }
}

export class MediationList {
    /**
    * List of mediation records
    */
    'results'?: Array<MediationRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<MediationRecord>"
        }    ];

    static getAttributeTypeMap() {
        return MediationList.attributeTypeMap;
    }
}

export class MediationRecord {
    'connectionId': string;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    'endpoint'?: string;
    'mediationId'?: string;
    'mediatorTerms'?: Array<string>;
    'recipientTerms'?: Array<string>;
    'role': string;
    'routingKeys'?: Array<string>;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        },
        {
            "name": "mediationId",
            "baseName": "mediation_id",
            "type": "string"
        },
        {
            "name": "mediatorTerms",
            "baseName": "mediator_terms",
            "type": "Array<string>"
        },
        {
            "name": "recipientTerms",
            "baseName": "recipient_terms",
            "type": "Array<string>"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "routingKeys",
            "baseName": "routing_keys",
            "type": "Array<string>"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MediationRecord.attributeTypeMap;
    }
}

export class Menu {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Introductory text for the menu
    */
    'description'?: string;
    /**
    * An optional error message to display in menu header
    */
    'errormsg'?: string;
    /**
    * List of menu options
    */
    'options': Array<MenuOption>;
    /**
    * Menu title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "errormsg",
            "baseName": "errormsg",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<MenuOption>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Menu.attributeTypeMap;
    }
}

export class MenuForm {
    /**
    * Additional descriptive text for menu form
    */
    'description'?: string;
    /**
    * List of form parameters
    */
    'params'?: Array<MenuFormParam>;
    /**
    * Alternative label for form submit button
    */
    'submitLabel'?: string;
    /**
    * Menu form title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "Array<MenuFormParam>"
        },
        {
            "name": "submitLabel",
            "baseName": "submit-label",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuForm.attributeTypeMap;
    }
}

export class MenuFormParam {
    /**
    * Default parameter value
    */
    '_default'?: string;
    /**
    * Additional descriptive text for menu form parameter
    */
    'description'?: string;
    /**
    * Menu parameter name
    */
    'name': string;
    /**
    * Whether parameter is required
    */
    'required'?: boolean;
    /**
    * Menu parameter title
    */
    'title': string;
    /**
    * Menu form parameter input type
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_default",
            "baseName": "default",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuFormParam.attributeTypeMap;
    }
}

export class MenuJson {
    /**
    * Introductory text for the menu
    */
    'description'?: string;
    /**
    * Optional error message to display in menu header
    */
    'errormsg'?: string;
    /**
    * List of menu options
    */
    'options': Array<MenuOption>;
    /**
    * Menu title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "errormsg",
            "baseName": "errormsg",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<MenuOption>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuJson.attributeTypeMap;
    }
}

export class MenuOption {
    /**
    * Additional descriptive text for menu option
    */
    'description'?: string;
    /**
    * Whether to show option as disabled
    */
    'disabled'?: boolean;
    'form'?: MenuForm;
    /**
    * Menu option name (unique identifier)
    */
    'name': string;
    /**
    * Menu option title
    */
    'title': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "form",
            "baseName": "form",
            "type": "MenuForm"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MenuOption.attributeTypeMap;
    }
}

export class ModelDate {
    /**
    * Expiry Date
    */
    'expiresTime': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expiresTime",
            "baseName": "expires_time",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ModelDate.attributeTypeMap;
    }
}

export class PerformRequest {
    /**
    * Menu option name
    */
    'name'?: string;
    /**
    * Input parameter values
    */
    'params'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return PerformRequest.attributeTypeMap;
    }
}

export class PingRequest {
    /**
    * Comment for the ping message
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PingRequest.attributeTypeMap;
    }
}

export class PingRequestResponse {
    /**
    * Thread ID of the ping message
    */
    'threadId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "threadId",
            "baseName": "thread_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PingRequestResponse.attributeTypeMap;
    }
}

export class PresentationDefinition {
    'format'?: ClaimFormat;
    /**
    * Unique Resource Identifier
    */
    'id'?: string;
    'inputDescriptors'?: Array<InputDescriptors>;
    /**
    * Human-friendly name that describes what the presentation definition pertains to
    */
    'name'?: string;
    /**
    * Describes the purpose for which the Presentation Definition's inputs are being requested
    */
    'purpose'?: string;
    'submissionRequirements'?: Array<SubmissionRequirements>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "format",
            "baseName": "format",
            "type": "ClaimFormat"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "inputDescriptors",
            "baseName": "input_descriptors",
            "type": "Array<InputDescriptors>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "purpose",
            "baseName": "purpose",
            "type": "string"
        },
        {
            "name": "submissionRequirements",
            "baseName": "submission_requirements",
            "type": "Array<SubmissionRequirements>"
        }    ];

    static getAttributeTypeMap() {
        return PresentationDefinition.attributeTypeMap;
    }
}

export class PresentationProposal {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'presentationProposal': IndyPresPreview;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "presentationProposal",
            "baseName": "presentation_proposal",
            "type": "IndyPresPreview"
        }    ];

    static getAttributeTypeMap() {
        return PresentationProposal.attributeTypeMap;
    }
}

export class PresentationRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'requestPresentationsattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "requestPresentationsattach",
            "baseName": "request_presentations~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return PresentationRequest.attributeTypeMap;
    }
}

export class ProtocolDescriptor {
    'pid': string;
    /**
    * List of roles
    */
    'roles'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pid",
            "baseName": "pid",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ProtocolDescriptor.attributeTypeMap;
    }
}

export class PublishRevocations {
    /**
    * Credential revocation ids by revocation registry id
    */
    'rrid2crid'?: { [key: string]: Array<string>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rrid2crid",
            "baseName": "rrid2crid",
            "type": "{ [key: string]: Array<string>; }"
        }    ];

    static getAttributeTypeMap() {
        return PublishRevocations.attributeTypeMap;
    }
}

export class Queries {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    'queries'?: Array<QueryItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "queries",
            "baseName": "queries",
            "type": "Array<QueryItem>"
        }    ];

    static getAttributeTypeMap() {
        return Queries.attributeTypeMap;
    }
}

export class Query {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    'comment'?: string;
    'query': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Query.attributeTypeMap;
    }
}

export class QueryItem {
    /**
    * feature type
    */
    'featureType': QueryItem.FeatureTypeEnum;
    /**
    * match
    */
    'match': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "featureType",
            "baseName": "feature-type",
            "type": "QueryItem.FeatureTypeEnum"
        },
        {
            "name": "match",
            "baseName": "match",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return QueryItem.attributeTypeMap;
    }
}

export namespace QueryItem {
    export enum FeatureTypeEnum {
        Protocol = <any> 'protocol',
        GoalCode = <any> 'goal-code'
    }
}
export class RawEncoded {
    /**
    * Encoded value
    */
    'encoded'?: string;
    /**
    * Raw value
    */
    'raw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "encoded",
            "baseName": "encoded",
            "type": "string"
        },
        {
            "name": "raw",
            "baseName": "raw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RawEncoded.attributeTypeMap;
    }
}

export class ReceiveInvitationRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * DID for connection invitation
    */
    'did'?: string;
    /**
    * Optional image URL for connection invitation
    */
    'imageUrl'?: string;
    /**
    * Optional label for connection invitation
    */
    'label'?: string;
    /**
    * List of recipient keys
    */
    'recipientKeys'?: Array<string>;
    /**
    * List of routing keys
    */
    'routingKeys'?: Array<string>;
    /**
    * Service endpoint at which to reach this agent
    */
    'serviceEndpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "did",
            "baseName": "did",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "recipientKeys",
            "baseName": "recipientKeys",
            "type": "Array<string>"
        },
        {
            "name": "routingKeys",
            "baseName": "routingKeys",
            "type": "Array<string>"
        },
        {
            "name": "serviceEndpoint",
            "baseName": "serviceEndpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReceiveInvitationRequest.attributeTypeMap;
    }
}

export class RegisterLedgerNymResponse {
    /**
    * Success of nym registration operation
    */
    'success'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RegisterLedgerNymResponse.attributeTypeMap;
    }
}

export class ResolutionResult {
    /**
    * DID Document
    */
    'didDoc': any;
    /**
    * Resolution metadata
    */
    'metadata': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "didDoc",
            "baseName": "did_doc",
            "type": "any"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ResolutionResult.attributeTypeMap;
    }
}

export class RevRegCreateRequest {
    /**
    * Credential definition identifier
    */
    'credentialDefinitionId'?: string;
    /**
    * Revocation registry size
    */
    'maxCredNum'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credentialDefinitionId",
            "baseName": "credential_definition_id",
            "type": "string"
        },
        {
            "name": "maxCredNum",
            "baseName": "max_cred_num",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevRegCreateRequest.attributeTypeMap;
    }
}

export class RevRegIssuedResult {
    /**
    * Number of credentials issued against revocation registry
    */
    'result'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RevRegIssuedResult.attributeTypeMap;
    }
}

export class RevRegResult {
    'result'?: IssuerRevRegRecord;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "IssuerRevRegRecord"
        }    ];

    static getAttributeTypeMap() {
        return RevRegResult.attributeTypeMap;
    }
}

export class RevRegUpdateTailsFileUri {
    /**
    * Public URI to the tails file
    */
    'tailsPublicUri': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tailsPublicUri",
            "baseName": "tails_public_uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RevRegUpdateTailsFileUri.attributeTypeMap;
    }
}

export class RevRegsCreated {
    'revRegIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "revRegIds",
            "baseName": "rev_reg_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RevRegsCreated.attributeTypeMap;
    }
}

export class RevocationModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RevocationModuleResponse.attributeTypeMap;
    }
}

export class RevokeRequest {
    /**
    * Optional comment to include in revocation notification
    */
    'comment'?: string;
    /**
    * Connection ID to which the revocation notification will be sent; required if notify is true
    */
    'connectionId'?: string;
    /**
    * Credential exchange identifier
    */
    'credExId'?: string;
    /**
    * Credential revocation identifier
    */
    'credRevId'?: string;
    /**
    * Send a notification to the credential recipient
    */
    'notify'?: boolean;
    /**
    * (True) publish revocation to ledger immediately, or (default, False) mark it pending
    */
    'publish'?: boolean;
    /**
    * Revocation registry identifier
    */
    'revRegId'?: string;
    /**
    * Thread ID of the credential exchange message thread resulting in the credential now being revoked; required if notify is true
    */
    'threadId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "credExId",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "credRevId",
            "baseName": "cred_rev_id",
            "type": "string"
        },
        {
            "name": "notify",
            "baseName": "notify",
            "type": "boolean"
        },
        {
            "name": "publish",
            "baseName": "publish",
            "type": "boolean"
        },
        {
            "name": "revRegId",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "threadId",
            "baseName": "thread_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RevokeRequest.attributeTypeMap;
    }
}

export class RouteRecord {
    'connectionId'?: string;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    'recipientKey': string;
    'recordId'?: string;
    'role'?: string;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;
    'walletId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "recipientKey",
            "baseName": "recipient_key",
            "type": "string"
        },
        {
            "name": "recordId",
            "baseName": "record_id",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "walletId",
            "baseName": "wallet_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RouteRecord.attributeTypeMap;
    }
}

export class Schema {
    /**
    * Schema attribute names
    */
    'attrNames'?: Array<string>;
    /**
    * Schema identifier
    */
    'id'?: string;
    /**
    * Schema name
    */
    'name'?: string;
    /**
    * Schema sequence number
    */
    'seqNo'?: number;
    /**
    * Node protocol version
    */
    'ver'?: string;
    /**
    * Schema version
    */
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attrNames",
            "baseName": "attrNames",
            "type": "Array<string>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "seqNo",
            "baseName": "seqNo",
            "type": "number"
        },
        {
            "name": "ver",
            "baseName": "ver",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Schema.attributeTypeMap;
    }
}

export class SchemaGetResult {
    'schema'?: Schema;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schema",
            "baseName": "schema",
            "type": "Schema"
        }    ];

    static getAttributeTypeMap() {
        return SchemaGetResult.attributeTypeMap;
    }
}

export class SchemaInputDescriptor {
    /**
    * Required
    */
    'required'?: boolean;
    /**
    * URI
    */
    'uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SchemaInputDescriptor.attributeTypeMap;
    }
}

export class SchemaSendRequest {
    /**
    * List of schema attributes
    */
    'attributes': Array<string>;
    /**
    * Schema name
    */
    'schemaName': string;
    /**
    * Schema version
    */
    'schemaVersion': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<string>"
        },
        {
            "name": "schemaName",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schemaVersion",
            "baseName": "schema_version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SchemaSendRequest.attributeTypeMap;
    }
}

export class SchemaSendResult {
    /**
    * Schema definition
    */
    'schema'?: any;
    /**
    * Schema identifier
    */
    'schemaId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schema",
            "baseName": "schema",
            "type": "any"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SchemaSendResult.attributeTypeMap;
    }
}

export class SchemasCreatedResult {
    'schemaIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schemaIds",
            "baseName": "schema_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SchemasCreatedResult.attributeTypeMap;
    }
}

export class SchemasInputDescriptorFilter {
    /**
    * oneOf
    */
    'oneofFilter'?: boolean;
    'uriGroups'?: Array<Array<SchemaInputDescriptor>>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "oneofFilter",
            "baseName": "oneof_filter",
            "type": "boolean"
        },
        {
            "name": "uriGroups",
            "baseName": "uri_groups",
            "type": "Array<Array<SchemaInputDescriptor>>"
        }    ];

    static getAttributeTypeMap() {
        return SchemasInputDescriptorFilter.attributeTypeMap;
    }
}

export class SendMenu {
    /**
    * Menu to send to connection
    */
    'menu': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "menu",
            "baseName": "menu",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return SendMenu.attributeTypeMap;
    }
}

export class SendMessage {
    /**
    * Message content
    */
    'content'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendMessage.attributeTypeMap;
    }
}

export class SignRequest {
    'doc': Doc;
    /**
    * Verkey to use for signing
    */
    'verkey': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "doc",
            "baseName": "doc",
            "type": "Doc"
        },
        {
            "name": "verkey",
            "baseName": "verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SignRequest.attributeTypeMap;
    }
}

export class SignResponse {
    /**
    * Error text
    */
    'error'?: string;
    /**
    * Signed document
    */
    'signedDoc'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "signedDoc",
            "baseName": "signed_doc",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return SignResponse.attributeTypeMap;
    }
}

export class SignatureOptions {
    'challenge'?: string;
    'domain'?: string;
    'proofPurpose': string;
    'type'?: string;
    'verificationMethod': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenge",
            "baseName": "challenge",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "proofPurpose",
            "baseName": "proofPurpose",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "verificationMethod",
            "baseName": "verificationMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SignatureOptions.attributeTypeMap;
    }
}

export class SignedDoc {
    /**
    * Linked data proof
    */
    'proof': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "proof",
            "baseName": "proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return SignedDoc.attributeTypeMap;
    }
}

export class SubmissionRequirements {
    /**
    * Count Value
    */
    'count'?: number;
    /**
    * From
    */
    'from'?: string;
    'fromNested'?: Array<SubmissionRequirements>;
    /**
    * Max Value
    */
    'max'?: number;
    /**
    * Min Value
    */
    'min'?: number;
    /**
    * Name
    */
    'name'?: string;
    /**
    * Purpose
    */
    'purpose'?: string;
    /**
    * Selection
    */
    'rule'?: SubmissionRequirements.RuleEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "fromNested",
            "baseName": "from_nested",
            "type": "Array<SubmissionRequirements>"
        },
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "purpose",
            "baseName": "purpose",
            "type": "string"
        },
        {
            "name": "rule",
            "baseName": "rule",
            "type": "SubmissionRequirements.RuleEnum"
        }    ];

    static getAttributeTypeMap() {
        return SubmissionRequirements.attributeTypeMap;
    }
}

export namespace SubmissionRequirements {
    export enum RuleEnum {
        All = <any> 'all',
        Pick = <any> 'pick'
    }
}
export class TAAAccept {
    'mechanism'?: string;
    'text'?: string;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mechanism",
            "baseName": "mechanism",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TAAAccept.attributeTypeMap;
    }
}

export class TAAAcceptance {
    'mechanism'?: string;
    'time'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mechanism",
            "baseName": "mechanism",
            "type": "string"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TAAAcceptance.attributeTypeMap;
    }
}

export class TAAInfo {
    'amlRecord'?: AMLRecord;
    'taaAccepted'?: TAAAcceptance;
    'taaRecord'?: TAARecord;
    'taaRequired'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amlRecord",
            "baseName": "aml_record",
            "type": "AMLRecord"
        },
        {
            "name": "taaAccepted",
            "baseName": "taa_accepted",
            "type": "TAAAcceptance"
        },
        {
            "name": "taaRecord",
            "baseName": "taa_record",
            "type": "TAARecord"
        },
        {
            "name": "taaRequired",
            "baseName": "taa_required",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TAAInfo.attributeTypeMap;
    }
}

export class TAARecord {
    'digest'?: string;
    'text'?: string;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "digest",
            "baseName": "digest",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TAARecord.attributeTypeMap;
    }
}

export class TAAResult {
    'result'?: TAAInfo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "TAAInfo"
        }    ];

    static getAttributeTypeMap() {
        return TAAResult.attributeTypeMap;
    }
}

export class TransactionJobs {
    /**
    * My transaction related job
    */
    'transactionMyJob'?: TransactionJobs.TransactionMyJobEnum;
    /**
    * Their transaction related job
    */
    'transactionTheirJob'?: TransactionJobs.TransactionTheirJobEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionMyJob",
            "baseName": "transaction_my_job",
            "type": "TransactionJobs.TransactionMyJobEnum"
        },
        {
            "name": "transactionTheirJob",
            "baseName": "transaction_their_job",
            "type": "TransactionJobs.TransactionTheirJobEnum"
        }    ];

    static getAttributeTypeMap() {
        return TransactionJobs.attributeTypeMap;
    }
}

export namespace TransactionJobs {
    export enum TransactionMyJobEnum {
        TRANSACTIONAUTHOR = <any> 'TRANSACTION_AUTHOR',
        TRANSACTIONENDORSER = <any> 'TRANSACTION_ENDORSER',
        Reset = <any> 'reset'
    }
    export enum TransactionTheirJobEnum {
        TRANSACTIONAUTHOR = <any> 'TRANSACTION_AUTHOR',
        TRANSACTIONENDORSER = <any> 'TRANSACTION_ENDORSER',
        Reset = <any> 'reset'
    }
}
export class TransactionList {
    /**
    * List of transaction records
    */
    'results'?: Array<TransactionRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<TransactionRecord>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionList.attributeTypeMap;
    }
}

export class TransactionRecord {
    /**
    * Transaction type
    */
    'type'?: string;
    /**
    * The connection identifier for thie particular transaction record
    */
    'connectionId'?: string;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * If True, Endorser will write the transaction after endorsing it
    */
    'endorserWriteTxn'?: boolean;
    'formats'?: Array<{ [key: string]: string; }>;
    'messagesAttach'?: Array<any>;
    'metaData'?: any;
    'signatureRequest'?: Array<any>;
    'signatureResponse'?: Array<any>;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Thread Identifier
    */
    'threadId'?: string;
    'timing'?: any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Transaction identifier
    */
    'transactionId'?: string;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "_type",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "endorserWriteTxn",
            "baseName": "endorser_write_txn",
            "type": "boolean"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<{ [key: string]: string; }>"
        },
        {
            "name": "messagesAttach",
            "baseName": "messages_attach",
            "type": "Array<any>"
        },
        {
            "name": "metaData",
            "baseName": "meta_data",
            "type": "any"
        },
        {
            "name": "signatureRequest",
            "baseName": "signature_request",
            "type": "Array<any>"
        },
        {
            "name": "signatureResponse",
            "baseName": "signature_response",
            "type": "Array<any>"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "threadId",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "timing",
            "baseName": "timing",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TransactionRecord.attributeTypeMap;
    }
}

export class TxnOrCredentialDefinitionSendResult {
    'sent'?: CredentialDefinitionSendResult;
    /**
    * Credential definition transaction to endorse
    */
    'txn'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sent",
            "baseName": "sent",
            "type": "CredentialDefinitionSendResult"
        },
        {
            "name": "txn",
            "baseName": "txn",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return TxnOrCredentialDefinitionSendResult.attributeTypeMap;
    }
}

export class TxnOrPublishRevocationsResult {
    'sent'?: PublishRevocations;
    /**
    * Revocation registry revocations transaction to endorse
    */
    'txn'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sent",
            "baseName": "sent",
            "type": "PublishRevocations"
        },
        {
            "name": "txn",
            "baseName": "txn",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return TxnOrPublishRevocationsResult.attributeTypeMap;
    }
}

export class TxnOrRevRegResult {
    'sent'?: RevRegResult;
    /**
    * Revocation registry definition transaction to endorse
    */
    'txn'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sent",
            "baseName": "sent",
            "type": "RevRegResult"
        },
        {
            "name": "txn",
            "baseName": "txn",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return TxnOrRevRegResult.attributeTypeMap;
    }
}

export class TxnOrSchemaSendResult {
    /**
    * Content sent
    */
    'sent'?: any;
    /**
    * Schema transaction to endorse
    */
    'txn'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sent",
            "baseName": "sent",
            "type": "any"
        },
        {
            "name": "txn",
            "baseName": "txn",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return TxnOrSchemaSendResult.attributeTypeMap;
    }
}

export class V10CredentialBoundOfferRequest {
    /**
    * Optional counter-proposal
    */
    'counterProposal'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "counterProposal",
            "baseName": "counter_proposal",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialBoundOfferRequest.attributeTypeMap;
    }
}

export class V10CredentialConnFreeOfferRequest {
    /**
    * Whether to respond automatically to credential requests, creating and issuing requested credentials
    */
    'autoIssue'?: boolean;
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Credential definition identifier
    */
    'credDefId': string;
    'credentialPreview': CredentialPreview;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoIssue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credentialPreview",
            "baseName": "credential_preview",
            "type": "CredentialPreview"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialConnFreeOfferRequest.attributeTypeMap;
    }
}

export class V10CredentialCreate {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    'credentialProposal': CredentialPreview;
    /**
    * Credential issuer DID
    */
    'issuerDid'?: string;
    /**
    * Schema identifier
    */
    'schemaId'?: string;
    /**
    * Schema issuer DID
    */
    'schemaIssuerDid'?: string;
    /**
    * Schema name
    */
    'schemaName'?: string;
    /**
    * Schema version
    */
    'schemaVersion'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credentialProposal",
            "baseName": "credential_proposal",
            "type": "CredentialPreview"
        },
        {
            "name": "issuerDid",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schemaIssuerDid",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schemaName",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schemaVersion",
            "baseName": "schema_version",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialCreate.attributeTypeMap;
    }
}

export class V10CredentialExchange {
    /**
    * Issuer choice to issue to request in this credential exchange
    */
    'autoIssue'?: boolean;
    /**
    * Holder choice to accept offer in this credential exchange
    */
    'autoOffer'?: boolean;
    /**
    * Issuer choice to remove this credential exchange record when complete
    */
    'autoRemove'?: boolean;
    /**
    * Connection identifier
    */
    'connectionId'?: string;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Credential as stored
    */
    'credential'?: any;
    /**
    * Credential definition identifier
    */
    'credentialDefinitionId'?: string;
    /**
    * Credential exchange identifier
    */
    'credentialExchangeId'?: string;
    /**
    * Credential identifier
    */
    'credentialId'?: string;
    /**
    * (Indy) credential offer
    */
    'credentialOffer'?: any;
    /**
    * Credential offer message
    */
    'credentialOfferDict'?: any;
    /**
    * Credential proposal message
    */
    'credentialProposalDict'?: any;
    /**
    * (Indy) credential request
    */
    'credentialRequest'?: any;
    /**
    * (Indy) credential request metadata
    */
    'credentialRequestMetadata'?: any;
    /**
    * Error message
    */
    'errorMsg'?: string;
    /**
    * Issue-credential exchange initiator: self or external
    */
    'initiator'?: V10CredentialExchange.InitiatorEnum;
    /**
    * Parent thread identifier
    */
    'parentThreadId'?: string;
    /**
    * Credential as received, prior to storage in holder wallet
    */
    'rawCredential'?: any;
    /**
    * Revocation registry identifier
    */
    'revocRegId'?: string;
    /**
    * Credential identifier within revocation registry
    */
    'revocationId'?: string;
    /**
    * Issue-credential exchange role: holder or issuer
    */
    'role'?: V10CredentialExchange.RoleEnum;
    /**
    * Schema identifier
    */
    'schemaId'?: string;
    /**
    * Issue-credential exchange state
    */
    'state'?: string;
    /**
    * Thread identifier
    */
    'threadId'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoIssue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "autoOffer",
            "baseName": "auto_offer",
            "type": "boolean"
        },
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "credential",
            "baseName": "credential",
            "type": "any"
        },
        {
            "name": "credentialDefinitionId",
            "baseName": "credential_definition_id",
            "type": "string"
        },
        {
            "name": "credentialExchangeId",
            "baseName": "credential_exchange_id",
            "type": "string"
        },
        {
            "name": "credentialId",
            "baseName": "credential_id",
            "type": "string"
        },
        {
            "name": "credentialOffer",
            "baseName": "credential_offer",
            "type": "any"
        },
        {
            "name": "credentialOfferDict",
            "baseName": "credential_offer_dict",
            "type": "any"
        },
        {
            "name": "credentialProposalDict",
            "baseName": "credential_proposal_dict",
            "type": "any"
        },
        {
            "name": "credentialRequest",
            "baseName": "credential_request",
            "type": "any"
        },
        {
            "name": "credentialRequestMetadata",
            "baseName": "credential_request_metadata",
            "type": "any"
        },
        {
            "name": "errorMsg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "V10CredentialExchange.InitiatorEnum"
        },
        {
            "name": "parentThreadId",
            "baseName": "parent_thread_id",
            "type": "string"
        },
        {
            "name": "rawCredential",
            "baseName": "raw_credential",
            "type": "any"
        },
        {
            "name": "revocRegId",
            "baseName": "revoc_reg_id",
            "type": "string"
        },
        {
            "name": "revocationId",
            "baseName": "revocation_id",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V10CredentialExchange.RoleEnum"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "threadId",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialExchange.attributeTypeMap;
    }
}

export namespace V10CredentialExchange {
    export enum InitiatorEnum {
        Self = <any> 'self',
        External = <any> 'external'
    }
    export enum RoleEnum {
        Holder = <any> 'holder',
        Issuer = <any> 'issuer'
    }
}
export class V10CredentialExchangeListResult {
    /**
    * Aries#0036 v1.0 credential exchange records
    */
    'results'?: Array<V10CredentialExchange>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<V10CredentialExchange>"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialExchangeListResult.attributeTypeMap;
    }
}

export class V10CredentialFreeOfferRequest {
    /**
    * Whether to respond automatically to credential requests, creating and issuing requested credentials
    */
    'autoIssue'?: boolean;
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    /**
    * Credential definition identifier
    */
    'credDefId': string;
    'credentialPreview': CredentialPreview;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoIssue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credentialPreview",
            "baseName": "credential_preview",
            "type": "CredentialPreview"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialFreeOfferRequest.attributeTypeMap;
    }
}

export class V10CredentialIssueRequest {
    /**
    * Human-readable comment
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialIssueRequest.attributeTypeMap;
    }
}

export class V10CredentialProblemReportRequest {
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialProblemReportRequest.attributeTypeMap;
    }
}

export class V10CredentialProposalRequestMand {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    'credentialProposal': CredentialPreview;
    /**
    * Credential issuer DID
    */
    'issuerDid'?: string;
    /**
    * Schema identifier
    */
    'schemaId'?: string;
    /**
    * Schema issuer DID
    */
    'schemaIssuerDid'?: string;
    /**
    * Schema name
    */
    'schemaName'?: string;
    /**
    * Schema version
    */
    'schemaVersion'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credentialProposal",
            "baseName": "credential_proposal",
            "type": "CredentialPreview"
        },
        {
            "name": "issuerDid",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schemaIssuerDid",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schemaName",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schemaVersion",
            "baseName": "schema_version",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialProposalRequestMand.attributeTypeMap;
    }
}

export class V10CredentialProposalRequestOpt {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    'credentialProposal'?: CredentialPreview;
    /**
    * Credential issuer DID
    */
    'issuerDid'?: string;
    /**
    * Schema identifier
    */
    'schemaId'?: string;
    /**
    * Schema issuer DID
    */
    'schemaIssuerDid'?: string;
    /**
    * Schema name
    */
    'schemaName'?: string;
    /**
    * Schema version
    */
    'schemaVersion'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "credentialProposal",
            "baseName": "credential_proposal",
            "type": "CredentialPreview"
        },
        {
            "name": "issuerDid",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schemaIssuerDid",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schemaName",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schemaVersion",
            "baseName": "schema_version",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialProposalRequestOpt.attributeTypeMap;
    }
}

export class V10CredentialStoreRequest {
    'credentialId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credentialId",
            "baseName": "credential_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10CredentialStoreRequest.attributeTypeMap;
    }
}

export class V10DiscoveryExchangeListResult {
    'results'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return V10DiscoveryExchangeListResult.attributeTypeMap;
    }
}

export class V10DiscoveryExchangeResult {
    /**
    * Discover Features v1.0 exchange record
    */
    'results'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V10DiscoveryExchangeResult.attributeTypeMap;
    }
}

export class V10DiscoveryRecord {
    /**
    * Connection identifier
    */
    'connectionId'?: string;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Disclose message
    */
    'disclose'?: any;
    /**
    * Credential exchange identifier
    */
    'discoveryExchangeId'?: string;
    /**
    * Query message
    */
    'queryMsg'?: any;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Thread identifier
    */
    'threadId'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "disclose",
            "baseName": "disclose",
            "type": "any"
        },
        {
            "name": "discoveryExchangeId",
            "baseName": "discovery_exchange_id",
            "type": "string"
        },
        {
            "name": "queryMsg",
            "baseName": "query_msg",
            "type": "any"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "threadId",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10DiscoveryRecord.attributeTypeMap;
    }
}

export class V10PresentProofModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V10PresentProofModuleResponse.attributeTypeMap;
    }
}

export class V10PresentationCreateRequestRequest {
    'comment'?: string;
    'proofRequest': IndyProofRequest;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "proofRequest",
            "baseName": "proof_request",
            "type": "IndyProofRequest"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationCreateRequestRequest.attributeTypeMap;
    }
}

export class V10PresentationExchange {
    /**
    * Prover choice to auto-present proof as verifier requests
    */
    'autoPresent'?: boolean;
    /**
    * Connection identifier
    */
    'connectionId'?: string;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Error message
    */
    'errorMsg'?: string;
    /**
    * Present-proof exchange initiator: self or external
    */
    'initiator'?: V10PresentationExchange.InitiatorEnum;
    /**
    * (Indy) presentation (also known as proof)
    */
    'presentation'?: any;
    /**
    * Presentation exchange identifier
    */
    'presentationExchangeId'?: string;
    /**
    * Presentation proposal message
    */
    'presentationProposalDict'?: any;
    /**
    * (Indy) presentation request (also known as proof request)
    */
    'presentationRequest'?: any;
    /**
    * Presentation request message
    */
    'presentationRequestDict'?: any;
    /**
    * Present-proof exchange role: prover or verifier
    */
    'role'?: V10PresentationExchange.RoleEnum;
    /**
    * Present-proof exchange state
    */
    'state'?: string;
    /**
    * Thread identifier
    */
    'threadId'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;
    /**
    * Whether presentation is verified: true or false
    */
    'verified'?: V10PresentationExchange.VerifiedEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoPresent",
            "baseName": "auto_present",
            "type": "boolean"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "errorMsg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "V10PresentationExchange.InitiatorEnum"
        },
        {
            "name": "presentation",
            "baseName": "presentation",
            "type": "any"
        },
        {
            "name": "presentationExchangeId",
            "baseName": "presentation_exchange_id",
            "type": "string"
        },
        {
            "name": "presentationProposalDict",
            "baseName": "presentation_proposal_dict",
            "type": "any"
        },
        {
            "name": "presentationRequest",
            "baseName": "presentation_request",
            "type": "any"
        },
        {
            "name": "presentationRequestDict",
            "baseName": "presentation_request_dict",
            "type": "any"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V10PresentationExchange.RoleEnum"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "threadId",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "V10PresentationExchange.VerifiedEnum"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationExchange.attributeTypeMap;
    }
}

export namespace V10PresentationExchange {
    export enum InitiatorEnum {
        Self = <any> 'self',
        External = <any> 'external'
    }
    export enum RoleEnum {
        Prover = <any> 'prover',
        Verifier = <any> 'verifier'
    }
    export enum VerifiedEnum {
        True = <any> 'true',
        False = <any> 'false'
    }
}
export class V10PresentationExchangeList {
    /**
    * Aries RFC 37 v1.0 presentation exchange records
    */
    'results'?: Array<V10PresentationExchange>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<V10PresentationExchange>"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationExchangeList.attributeTypeMap;
    }
}

export class V10PresentationProblemReportRequest {
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationProblemReportRequest.attributeTypeMap;
    }
}

export class V10PresentationProposalRequest {
    /**
    * Whether to respond automatically to presentation requests, building and presenting requested proof
    */
    'autoPresent'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    'presentationProposal': IndyPresPreview;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoPresent",
            "baseName": "auto_present",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "presentationProposal",
            "baseName": "presentation_proposal",
            "type": "IndyPresPreview"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationProposalRequest.attributeTypeMap;
    }
}

export class V10PresentationSendRequestRequest {
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    'proofRequest': IndyProofRequest;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "proofRequest",
            "baseName": "proof_request",
            "type": "IndyProofRequest"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V10PresentationSendRequestRequest.attributeTypeMap;
    }
}

export class V20CredAttrSpec {
    /**
    * MIME type: omit for (null) default
    */
    'mimeType'?: string;
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Attribute value: base64-encode if MIME type is present
    */
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mimeType",
            "baseName": "mime-type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredAttrSpec.attributeTypeMap;
    }
}

export class V20CredBoundOfferRequest {
    /**
    * Optional content for counter-proposal
    */
    'counterPreview'?: any;
    /**
    * Credential specification criteria by format
    */
    'filter'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "counterPreview",
            "baseName": "counter_preview",
            "type": "any"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20CredBoundOfferRequest.attributeTypeMap;
    }
}

export class V20CredExFree {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    'credentialPreview'?: V20CredPreview;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "credentialPreview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExFree.attributeTypeMap;
    }
}

export class V20CredExRecord {
    /**
    * Issuer choice to issue to request in this credential exchange
    */
    'autoIssue'?: boolean;
    /**
    * Holder choice to accept offer in this credential exchange
    */
    'autoOffer'?: boolean;
    /**
    * Issuer choice to remove this credential exchange record when complete
    */
    'autoRemove'?: boolean;
    /**
    * Attachment content by format for proposal, offer, request, and issue
    */
    'byFormat'?: any;
    /**
    * Connection identifier
    */
    'connectionId'?: string;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Credential exchange identifier
    */
    'credExId'?: string;
    /**
    * Serialized credential issue message
    */
    'credIssue'?: any;
    /**
    * Credential offer message
    */
    'credOffer'?: any;
    /**
    * Credential preview from credential proposal
    */
    'credPreview'?: any;
    /**
    * Credential proposal message
    */
    'credProposal'?: any;
    /**
    * Serialized credential request message
    */
    'credRequest'?: any;
    /**
    * Error message
    */
    'errorMsg'?: string;
    /**
    * Issue-credential exchange initiator: self or external
    */
    'initiator'?: V20CredExRecord.InitiatorEnum;
    /**
    * Parent thread identifier
    */
    'parentThreadId'?: string;
    /**
    * Issue-credential exchange role: holder or issuer
    */
    'role'?: V20CredExRecord.RoleEnum;
    /**
    * Issue-credential exchange state
    */
    'state'?: V20CredExRecord.StateEnum;
    /**
    * Thread identifier
    */
    'threadId'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoIssue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "autoOffer",
            "baseName": "auto_offer",
            "type": "boolean"
        },
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "byFormat",
            "baseName": "by_format",
            "type": "any"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "credExId",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "credIssue",
            "baseName": "cred_issue",
            "type": "any"
        },
        {
            "name": "credOffer",
            "baseName": "cred_offer",
            "type": "any"
        },
        {
            "name": "credPreview",
            "baseName": "cred_preview",
            "type": "any"
        },
        {
            "name": "credProposal",
            "baseName": "cred_proposal",
            "type": "any"
        },
        {
            "name": "credRequest",
            "baseName": "cred_request",
            "type": "any"
        },
        {
            "name": "errorMsg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "V20CredExRecord.InitiatorEnum"
        },
        {
            "name": "parentThreadId",
            "baseName": "parent_thread_id",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V20CredExRecord.RoleEnum"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "V20CredExRecord.StateEnum"
        },
        {
            "name": "threadId",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecord.attributeTypeMap;
    }
}

export namespace V20CredExRecord {
    export enum InitiatorEnum {
        Self = <any> 'self',
        External = <any> 'external'
    }
    export enum RoleEnum {
        Issuer = <any> 'issuer',
        Holder = <any> 'holder'
    }
    export enum StateEnum {
        ProposalSent = <any> 'proposal-sent',
        ProposalReceived = <any> 'proposal-received',
        OfferSent = <any> 'offer-sent',
        OfferReceived = <any> 'offer-received',
        RequestSent = <any> 'request-sent',
        RequestReceived = <any> 'request-received',
        CredentialIssued = <any> 'credential-issued',
        CredentialReceived = <any> 'credential-received',
        Done = <any> 'done',
        CredentialRevoked = <any> 'credential-revoked'
    }
}
export class V20CredExRecordByFormat {
    'credIssue'?: any;
    'credOffer'?: any;
    'credProposal'?: any;
    'credRequest'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credIssue",
            "baseName": "cred_issue",
            "type": "any"
        },
        {
            "name": "credOffer",
            "baseName": "cred_offer",
            "type": "any"
        },
        {
            "name": "credProposal",
            "baseName": "cred_proposal",
            "type": "any"
        },
        {
            "name": "credRequest",
            "baseName": "cred_request",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordByFormat.attributeTypeMap;
    }
}

export class V20CredExRecordDetail {
    /**
    * Credential exchange record
    */
    'credExRecord'?: any;
    'indy'?: V20CredExRecordIndy;
    'ldProof'?: V20CredExRecordLDProof;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credExRecord",
            "baseName": "cred_ex_record",
            "type": "any"
        },
        {
            "name": "indy",
            "baseName": "indy",
            "type": "V20CredExRecordIndy"
        },
        {
            "name": "ldProof",
            "baseName": "ld_proof",
            "type": "V20CredExRecordLDProof"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordDetail.attributeTypeMap;
    }
}

export class V20CredExRecordIndy {
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Corresponding v2.0 credential exchange record identifier
    */
    'credExId'?: string;
    /**
    * Record identifier
    */
    'credExIndyId'?: string;
    /**
    * Credential identifier stored in wallet
    */
    'credIdStored'?: string;
    /**
    * Credential request metadata for indy holder
    */
    'credRequestMetadata'?: any;
    /**
    * Credential revocation identifier within revocation registry
    */
    'credRevId'?: string;
    /**
    * Revocation registry identifier
    */
    'revRegId'?: string;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "credExId",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "credExIndyId",
            "baseName": "cred_ex_indy_id",
            "type": "string"
        },
        {
            "name": "credIdStored",
            "baseName": "cred_id_stored",
            "type": "string"
        },
        {
            "name": "credRequestMetadata",
            "baseName": "cred_request_metadata",
            "type": "any"
        },
        {
            "name": "credRevId",
            "baseName": "cred_rev_id",
            "type": "string"
        },
        {
            "name": "revRegId",
            "baseName": "rev_reg_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordIndy.attributeTypeMap;
    }
}

export class V20CredExRecordLDProof {
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Corresponding v2.0 credential exchange record identifier
    */
    'credExId'?: string;
    /**
    * Record identifier
    */
    'credExLdProofId'?: string;
    /**
    * Credential identifier stored in wallet
    */
    'credIdStored'?: string;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "credExId",
            "baseName": "cred_ex_id",
            "type": "string"
        },
        {
            "name": "credExLdProofId",
            "baseName": "cred_ex_ld_proof_id",
            "type": "string"
        },
        {
            "name": "credIdStored",
            "baseName": "cred_id_stored",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordLDProof.attributeTypeMap;
    }
}

export class V20CredExRecordListResult {
    /**
    * Credential exchange records and corresponding detail records
    */
    'results'?: Array<V20CredExRecordDetail>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<V20CredExRecordDetail>"
        }    ];

    static getAttributeTypeMap() {
        return V20CredExRecordListResult.attributeTypeMap;
    }
}

export class V20CredFilter {
    /**
    * Credential filter for indy
    */
    'indy'?: any;
    /**
    * Credential filter for linked data proof
    */
    'ldProof'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "indy",
            "baseName": "indy",
            "type": "any"
        },
        {
            "name": "ldProof",
            "baseName": "ld_proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20CredFilter.attributeTypeMap;
    }
}

export class V20CredFilterIndy {
    /**
    * Credential definition identifier
    */
    'credDefId'?: string;
    /**
    * Credential issuer DID
    */
    'issuerDid'?: string;
    /**
    * Schema identifier
    */
    'schemaId'?: string;
    /**
    * Schema issuer DID
    */
    'schemaIssuerDid'?: string;
    /**
    * Schema name
    */
    'schemaName'?: string;
    /**
    * Schema version
    */
    'schemaVersion'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credDefId",
            "baseName": "cred_def_id",
            "type": "string"
        },
        {
            "name": "issuerDid",
            "baseName": "issuer_did",
            "type": "string"
        },
        {
            "name": "schemaId",
            "baseName": "schema_id",
            "type": "string"
        },
        {
            "name": "schemaIssuerDid",
            "baseName": "schema_issuer_did",
            "type": "string"
        },
        {
            "name": "schemaName",
            "baseName": "schema_name",
            "type": "string"
        },
        {
            "name": "schemaVersion",
            "baseName": "schema_version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredFilterIndy.attributeTypeMap;
    }
}

export class V20CredFilterLDProof {
    /**
    * Credential filter for linked data proof
    */
    'ldProof': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ldProof",
            "baseName": "ld_proof",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20CredFilterLDProof.attributeTypeMap;
    }
}

export class V20CredFormat {
    /**
    * Attachment identifier
    */
    'attachId': string;
    /**
    * Attachment format specifier
    */
    'format': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachId",
            "baseName": "attach_id",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredFormat.attributeTypeMap;
    }
}

export class V20CredIssue {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Credential attachments
    */
    'credentialsattach': Array<AttachDecorator>;
    /**
    * Acceptable attachment formats
    */
    'formats': Array<V20CredFormat>;
    /**
    * Issuer-unique identifier to coordinate credential replacement
    */
    'replacementId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credentialsattach",
            "baseName": "credentials~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20CredFormat>"
        },
        {
            "name": "replacementId",
            "baseName": "replacement_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredIssue.attributeTypeMap;
    }
}

export class V20CredIssueProblemReportRequest {
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredIssueProblemReportRequest.attributeTypeMap;
    }
}

export class V20CredIssueRequest {
    /**
    * Human-readable comment
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredIssueRequest.attributeTypeMap;
    }
}

export class V20CredOffer {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'credentialPreview'?: V20CredPreview;
    /**
    * Acceptable credential formats
    */
    'formats': Array<V20CredFormat>;
    /**
    * Offer attachments
    */
    'offersattach': Array<AttachDecorator>;
    /**
    * Issuer-unique identifier to coordinate credential replacement
    */
    'replacementId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credentialPreview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20CredFormat>"
        },
        {
            "name": "offersattach",
            "baseName": "offers~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "replacementId",
            "baseName": "replacement_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredOffer.attributeTypeMap;
    }
}

export class V20CredOfferConnFreeRequest {
    /**
    * Whether to respond automatically to credential requests, creating and issuing requested credentials
    */
    'autoIssue'?: boolean;
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'credentialPreview'?: V20CredPreview;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoIssue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credentialPreview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20CredOfferConnFreeRequest.attributeTypeMap;
    }
}

export class V20CredOfferRequest {
    /**
    * Whether to respond automatically to credential requests, creating and issuing requested credentials
    */
    'autoIssue'?: boolean;
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    'credentialPreview'?: V20CredPreview;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoIssue",
            "baseName": "auto_issue",
            "type": "boolean"
        },
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "credentialPreview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20CredOfferRequest.attributeTypeMap;
    }
}

export class V20CredPreview {
    /**
    * Message type identifier
    */
    'type'?: string;
    'attributes': Array<V20CredAttrSpec>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<V20CredAttrSpec>"
        }    ];

    static getAttributeTypeMap() {
        return V20CredPreview.attributeTypeMap;
    }
}

export class V20CredProposal {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Credential preview
    */
    'credentialPreview'?: any;
    /**
    * Credential filter per acceptable format on corresponding identifier
    */
    'filtersattach': Array<AttachDecorator>;
    /**
    * Attachment formats
    */
    'formats': Array<V20CredFormat>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credentialPreview",
            "baseName": "credential_preview",
            "type": "any"
        },
        {
            "name": "filtersattach",
            "baseName": "filters~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20CredFormat>"
        }    ];

    static getAttributeTypeMap() {
        return V20CredProposal.attributeTypeMap;
    }
}

export class V20CredRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Acceptable attachment formats
    */
    'formats': Array<V20CredFormat>;
    /**
    * Request attachments
    */
    'requestsattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20CredFormat>"
        },
        {
            "name": "requestsattach",
            "baseName": "requests~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return V20CredRequest.attributeTypeMap;
    }
}

export class V20CredRequestFree {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Holder DID to substitute for the credentialSubject.id
    */
    'holderDid'?: string;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "holderDid",
            "baseName": "holder_did",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20CredRequestFree.attributeTypeMap;
    }
}

export class V20CredRequestRequest {
    /**
    * Holder DID to substitute for the credentialSubject.id
    */
    'holderDid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "holderDid",
            "baseName": "holder_did",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredRequestRequest.attributeTypeMap;
    }
}

export class V20CredStoreRequest {
    'credentialId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credentialId",
            "baseName": "credential_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20CredStoreRequest.attributeTypeMap;
    }
}

export class V20DiscoveryExchangeListResult {
    'results'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return V20DiscoveryExchangeListResult.attributeTypeMap;
    }
}

export class V20DiscoveryExchangeResult {
    /**
    * Discover Features v2.0 exchange record
    */
    'results'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20DiscoveryExchangeResult.attributeTypeMap;
    }
}

export class V20DiscoveryRecord {
    /**
    * Connection identifier
    */
    'connectionId'?: string;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Disclosures message
    */
    'disclosures'?: any;
    /**
    * Credential exchange identifier
    */
    'discoveryExchangeId'?: string;
    /**
    * Queries message
    */
    'queriesMsg'?: any;
    /**
    * Current record state
    */
    'state'?: string;
    /**
    * Thread identifier
    */
    'threadId'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "disclosures",
            "baseName": "disclosures",
            "type": "any"
        },
        {
            "name": "discoveryExchangeId",
            "baseName": "discovery_exchange_id",
            "type": "string"
        },
        {
            "name": "queriesMsg",
            "baseName": "queries_msg",
            "type": "any"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "threadId",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20DiscoveryRecord.attributeTypeMap;
    }
}

export class V20IssueCredSchemaCore {
    /**
    * Whether to remove the credential exchange record on completion (overrides --preserve-exchange-records configuration setting)
    */
    'autoRemove'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'credentialPreview'?: V20CredPreview;
    /**
    * Credential specification criteria by format
    */
    'filter': any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoRemove",
            "baseName": "auto_remove",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "credentialPreview",
            "baseName": "credential_preview",
            "type": "V20CredPreview"
        },
        {
            "name": "filter",
            "baseName": "filter",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20IssueCredSchemaCore.attributeTypeMap;
    }
}

export class V20IssueCredentialModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V20IssueCredentialModuleResponse.attributeTypeMap;
    }
}

export class V20Pres {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Acceptable attachment formats
    */
    'formats': Array<V20PresFormat>;
    'presentationsattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20PresFormat>"
        },
        {
            "name": "presentationsattach",
            "baseName": "presentations~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return V20Pres.attributeTypeMap;
    }
}

export class V20PresCreateRequestRequest {
    'comment'?: string;
    'presentationRequest': V20PresRequestByFormat;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "presentationRequest",
            "baseName": "presentation_request",
            "type": "V20PresRequestByFormat"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresCreateRequestRequest.attributeTypeMap;
    }
}

export class V20PresExRecord {
    /**
    * Prover choice to auto-present proof as verifier requests
    */
    'autoPresent'?: boolean;
    /**
    * Attachment content by format for proposal, request, and presentation
    */
    'byFormat'?: any;
    /**
    * Connection identifier
    */
    'connectionId'?: string;
    /**
    * Time of record creation
    */
    'createdAt'?: string;
    /**
    * Error message
    */
    'errorMsg'?: string;
    /**
    * Present-proof exchange initiator: self or external
    */
    'initiator'?: V20PresExRecord.InitiatorEnum;
    /**
    * Presentation message
    */
    'pres'?: any;
    /**
    * Presentation exchange identifier
    */
    'presExId'?: string;
    /**
    * Presentation proposal message
    */
    'presProposal'?: any;
    /**
    * Presentation request message
    */
    'presRequest'?: any;
    /**
    * Present-proof exchange role: prover or verifier
    */
    'role'?: V20PresExRecord.RoleEnum;
    /**
    * Present-proof exchange state
    */
    'state'?: V20PresExRecord.StateEnum;
    /**
    * Thread identifier
    */
    'threadId'?: string;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;
    /**
    * Time of last record update
    */
    'updatedAt'?: string;
    /**
    * Whether presentation is verified: 'true' or 'false'
    */
    'verified'?: V20PresExRecord.VerifiedEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoPresent",
            "baseName": "auto_present",
            "type": "boolean"
        },
        {
            "name": "byFormat",
            "baseName": "by_format",
            "type": "any"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "errorMsg",
            "baseName": "error_msg",
            "type": "string"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "V20PresExRecord.InitiatorEnum"
        },
        {
            "name": "pres",
            "baseName": "pres",
            "type": "any"
        },
        {
            "name": "presExId",
            "baseName": "pres_ex_id",
            "type": "string"
        },
        {
            "name": "presProposal",
            "baseName": "pres_proposal",
            "type": "any"
        },
        {
            "name": "presRequest",
            "baseName": "pres_request",
            "type": "any"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V20PresExRecord.RoleEnum"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "V20PresExRecord.StateEnum"
        },
        {
            "name": "threadId",
            "baseName": "thread_id",
            "type": "string"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "V20PresExRecord.VerifiedEnum"
        }    ];

    static getAttributeTypeMap() {
        return V20PresExRecord.attributeTypeMap;
    }
}

export namespace V20PresExRecord {
    export enum InitiatorEnum {
        Self = <any> 'self',
        External = <any> 'external'
    }
    export enum RoleEnum {
        Prover = <any> 'prover',
        Verifier = <any> 'verifier'
    }
    export enum StateEnum {
        ProposalSent = <any> 'proposal-sent',
        ProposalReceived = <any> 'proposal-received',
        RequestSent = <any> 'request-sent',
        RequestReceived = <any> 'request-received',
        PresentationSent = <any> 'presentation-sent',
        PresentationReceived = <any> 'presentation-received',
        Done = <any> 'done',
        Abandoned = <any> 'abandoned'
    }
    export enum VerifiedEnum {
        True = <any> 'true',
        False = <any> 'false'
    }
}
export class V20PresExRecordByFormat {
    'pres'?: any;
    'presProposal'?: any;
    'presRequest'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pres",
            "baseName": "pres",
            "type": "any"
        },
        {
            "name": "presProposal",
            "baseName": "pres_proposal",
            "type": "any"
        },
        {
            "name": "presRequest",
            "baseName": "pres_request",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20PresExRecordByFormat.attributeTypeMap;
    }
}

export class V20PresExRecordList {
    /**
    * Presentation exchange records
    */
    'results'?: Array<V20PresExRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<V20PresExRecord>"
        }    ];

    static getAttributeTypeMap() {
        return V20PresExRecordList.attributeTypeMap;
    }
}

export class V20PresFormat {
    /**
    * Attachment identifier
    */
    'attachId': string;
    /**
    * Attachment format specifier
    */
    'format': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachId",
            "baseName": "attach_id",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20PresFormat.attributeTypeMap;
    }
}

export class V20PresProblemReportRequest {
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V20PresProblemReportRequest.attributeTypeMap;
    }
}

export class V20PresProposal {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'formats': Array<V20PresFormat>;
    /**
    * Attachment per acceptable format on corresponding identifier
    */
    'proposalsattach': Array<AttachDecorator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20PresFormat>"
        },
        {
            "name": "proposalsattach",
            "baseName": "proposals~attach",
            "type": "Array<AttachDecorator>"
        }    ];

    static getAttributeTypeMap() {
        return V20PresProposal.attributeTypeMap;
    }
}

export class V20PresProposalByFormat {
    /**
    * Presentation proposal for DIF
    */
    'dif'?: any;
    /**
    * Presentation proposal for indy
    */
    'indy'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dif",
            "baseName": "dif",
            "type": "any"
        },
        {
            "name": "indy",
            "baseName": "indy",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20PresProposalByFormat.attributeTypeMap;
    }
}

export class V20PresProposalRequest {
    /**
    * Whether to respond automatically to presentation requests, building and presenting requested proof
    */
    'autoPresent'?: boolean;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    'presentationProposal': V20PresProposalByFormat;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoPresent",
            "baseName": "auto_present",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "presentationProposal",
            "baseName": "presentation_proposal",
            "type": "V20PresProposalByFormat"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresProposalRequest.attributeTypeMap;
    }
}

export class V20PresRequest {
    /**
    * Message identifier
    */
    'id'?: string;
    /**
    * Message type
    */
    'type'?: string;
    /**
    * Human-readable comment
    */
    'comment'?: string;
    'formats': Array<V20PresFormat>;
    /**
    * Attachment per acceptable format on corresponding identifier
    */
    'requestPresentationsattach': Array<AttachDecorator>;
    /**
    * Whether verifier will send confirmation ack
    */
    'willConfirm'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "@id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "@type",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "formats",
            "baseName": "formats",
            "type": "Array<V20PresFormat>"
        },
        {
            "name": "requestPresentationsattach",
            "baseName": "request_presentations~attach",
            "type": "Array<AttachDecorator>"
        },
        {
            "name": "willConfirm",
            "baseName": "will_confirm",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresRequest.attributeTypeMap;
    }
}

export class V20PresRequestByFormat {
    /**
    * Presentation request for DIF
    */
    'dif'?: any;
    /**
    * Presentation request for indy
    */
    'indy'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dif",
            "baseName": "dif",
            "type": "any"
        },
        {
            "name": "indy",
            "baseName": "indy",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V20PresRequestByFormat.attributeTypeMap;
    }
}

export class V20PresSendRequestRequest {
    'comment'?: string;
    /**
    * Connection identifier
    */
    'connectionId': string;
    'presentationRequest': V20PresRequestByFormat;
    /**
    * Whether to trace event (default false)
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "connectionId",
            "baseName": "connection_id",
            "type": "string"
        },
        {
            "name": "presentationRequest",
            "baseName": "presentation_request",
            "type": "V20PresRequestByFormat"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresSendRequestRequest.attributeTypeMap;
    }
}

export class V20PresSpecByFormatRequest {
    /**
    * Optional Presentation specification for DIF, overrides the PresentionExchange record's PresRequest
    */
    'dif'?: any;
    /**
    * Presentation specification for indy
    */
    'indy'?: any;
    /**
    * Record trace information, based on agent configuration
    */
    'trace'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dif",
            "baseName": "dif",
            "type": "any"
        },
        {
            "name": "indy",
            "baseName": "indy",
            "type": "any"
        },
        {
            "name": "trace",
            "baseName": "trace",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return V20PresSpecByFormatRequest.attributeTypeMap;
    }
}

export class V20PresentProofModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V20PresentProofModuleResponse.attributeTypeMap;
    }
}

export class VCRecord {
    'contexts'?: Array<string>;
    'credTags'?: { [key: string]: string; };
    /**
    * (JSON-serializable) credential value
    */
    'credValue'?: any;
    'expandedTypes'?: Array<string>;
    /**
    * Credential identifier
    */
    'givenId'?: string;
    /**
    * Issuer identifier
    */
    'issuerId'?: string;
    'proofTypes'?: Array<string>;
    /**
    * Record identifier
    */
    'recordId'?: string;
    'schemaIds'?: Array<string>;
    'subjectIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contexts",
            "baseName": "contexts",
            "type": "Array<string>"
        },
        {
            "name": "credTags",
            "baseName": "cred_tags",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "credValue",
            "baseName": "cred_value",
            "type": "any"
        },
        {
            "name": "expandedTypes",
            "baseName": "expanded_types",
            "type": "Array<string>"
        },
        {
            "name": "givenId",
            "baseName": "given_id",
            "type": "string"
        },
        {
            "name": "issuerId",
            "baseName": "issuer_id",
            "type": "string"
        },
        {
            "name": "proofTypes",
            "baseName": "proof_types",
            "type": "Array<string>"
        },
        {
            "name": "recordId",
            "baseName": "record_id",
            "type": "string"
        },
        {
            "name": "schemaIds",
            "baseName": "schema_ids",
            "type": "Array<string>"
        },
        {
            "name": "subjectIds",
            "baseName": "subject_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return VCRecord.attributeTypeMap;
    }
}

export class VCRecordList {
    'results'?: Array<VCRecord>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<VCRecord>"
        }    ];

    static getAttributeTypeMap() {
        return VCRecordList.attributeTypeMap;
    }
}

export class VerifyRequest {
    /**
    * Signed document
    */
    'doc': any;
    /**
    * Verkey to use for doc verification
    */
    'verkey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "doc",
            "baseName": "doc",
            "type": "any"
        },
        {
            "name": "verkey",
            "baseName": "verkey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VerifyRequest.attributeTypeMap;
    }
}

export class VerifyResponse {
    /**
    * Error text
    */
    'error'?: string;
    'valid': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "valid",
            "baseName": "valid",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VerifyResponse.attributeTypeMap;
    }
}

export class W3CCredentialsListRequest {
    'contexts'?: Array<string>;
    /**
    * Given credential id to match
    */
    'givenId'?: string;
    /**
    * Credential issuer identifier to match
    */
    'issuerId'?: string;
    /**
    * Maximum number of results to return
    */
    'maxResults'?: number;
    'proofTypes'?: Array<string>;
    /**
    * Schema identifiers, all of which to match
    */
    'schemaIds'?: Array<string>;
    /**
    * Subject identifiers, all of which to match
    */
    'subjectIds'?: Array<string>;
    /**
    * Tag filter
    */
    'tagQuery'?: { [key: string]: string; };
    'types'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contexts",
            "baseName": "contexts",
            "type": "Array<string>"
        },
        {
            "name": "givenId",
            "baseName": "given_id",
            "type": "string"
        },
        {
            "name": "issuerId",
            "baseName": "issuer_id",
            "type": "string"
        },
        {
            "name": "maxResults",
            "baseName": "max_results",
            "type": "number"
        },
        {
            "name": "proofTypes",
            "baseName": "proof_types",
            "type": "Array<string>"
        },
        {
            "name": "schemaIds",
            "baseName": "schema_ids",
            "type": "Array<string>"
        },
        {
            "name": "subjectIds",
            "baseName": "subject_ids",
            "type": "Array<string>"
        },
        {
            "name": "tagQuery",
            "baseName": "tag_query",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "types",
            "baseName": "types",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return W3CCredentialsListRequest.attributeTypeMap;
    }
}

export class WalletModuleResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return WalletModuleResponse.attributeTypeMap;
    }
}

export class WriteLedgerRequest {
    'ledgerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ledgerId",
            "baseName": "ledger_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WriteLedgerRequest.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AttachmentDef.TypeEnum": AttachmentDef.TypeEnum,
        "ConnRecord.AcceptEnum": ConnRecord.AcceptEnum,
        "ConnRecord.ConnectionProtocolEnum": ConnRecord.ConnectionProtocolEnum,
        "ConnRecord.InvitationModeEnum": ConnRecord.InvitationModeEnum,
        "ConnRecord.RoutingStateEnum": ConnRecord.RoutingStateEnum,
        "ConnRecord.TheirRoleEnum": ConnRecord.TheirRoleEnum,
        "Constraints.StatusActiveEnum": Constraints.StatusActiveEnum,
        "Constraints.StatusRevokedEnum": Constraints.StatusRevokedEnum,
        "Constraints.StatusSuspendedEnum": Constraints.StatusSuspendedEnum,
        "Constraints.SubjectIsIssuerEnum": Constraints.SubjectIsIssuerEnum,
        "DID.KeyTypeEnum": DID.KeyTypeEnum,
        "DID.MethodEnum": DID.MethodEnum,
        "DID.PostureEnum": DID.PostureEnum,
        "DIDCreate.MethodEnum": DIDCreate.MethodEnum,
        "DIDCreateOptions.KeyTypeEnum": DIDCreateOptions.KeyTypeEnum,
        "DIDEndpointWithType.EndpointTypeEnum": DIDEndpointWithType.EndpointTypeEnum,
        "DIFField.PredicateEnum": DIFField.PredicateEnum,
        "DIFHolder.DirectiveEnum": DIFHolder.DirectiveEnum,
        "GetNymRoleResponse.RoleEnum": GetNymRoleResponse.RoleEnum,
        "IndyGEProofPred.PTypeEnum": IndyGEProofPred.PTypeEnum,
        "IndyPresPredSpec.PredicateEnum": IndyPresPredSpec.PredicateEnum,
        "IndyProofReqPredSpec.PTypeEnum": IndyProofReqPredSpec.PTypeEnum,
        "IndyRevRegDef.RevocDefTypeEnum": IndyRevRegDef.RevocDefTypeEnum,
        "IndyRevRegDefValue.IssuanceTypeEnum": IndyRevRegDefValue.IssuanceTypeEnum,
        "IssuerRevRegRecord.RevocDefTypeEnum": IssuerRevRegRecord.RevocDefTypeEnum,
        "KeylistUpdateRule.ActionEnum": KeylistUpdateRule.ActionEnum,
        "QueryItem.FeatureTypeEnum": QueryItem.FeatureTypeEnum,
        "SubmissionRequirements.RuleEnum": SubmissionRequirements.RuleEnum,
        "TransactionJobs.TransactionMyJobEnum": TransactionJobs.TransactionMyJobEnum,
        "TransactionJobs.TransactionTheirJobEnum": TransactionJobs.TransactionTheirJobEnum,
        "V10CredentialExchange.InitiatorEnum": V10CredentialExchange.InitiatorEnum,
        "V10CredentialExchange.RoleEnum": V10CredentialExchange.RoleEnum,
        "V10PresentationExchange.InitiatorEnum": V10PresentationExchange.InitiatorEnum,
        "V10PresentationExchange.RoleEnum": V10PresentationExchange.RoleEnum,
        "V10PresentationExchange.VerifiedEnum": V10PresentationExchange.VerifiedEnum,
        "V20CredExRecord.InitiatorEnum": V20CredExRecord.InitiatorEnum,
        "V20CredExRecord.RoleEnum": V20CredExRecord.RoleEnum,
        "V20CredExRecord.StateEnum": V20CredExRecord.StateEnum,
        "V20PresExRecord.InitiatorEnum": V20PresExRecord.InitiatorEnum,
        "V20PresExRecord.RoleEnum": V20PresExRecord.RoleEnum,
        "V20PresExRecord.StateEnum": V20PresExRecord.StateEnum,
        "V20PresExRecord.VerifiedEnum": V20PresExRecord.VerifiedEnum,
}

let typeMap: {[index: string]: any} = {
    "AMLRecord": AMLRecord,
    "ActionMenuFetchResult": ActionMenuFetchResult,
    "ActionMenuModulesResult": ActionMenuModulesResult,
    "AdminAPIMessageTracing": AdminAPIMessageTracing,
    "AdminConfig": AdminConfig,
    "AdminMediationDeny": AdminMediationDeny,
    "AdminModules": AdminModules,
    "AdminReset": AdminReset,
    "AdminShutdown": AdminShutdown,
    "AdminStatus": AdminStatus,
    "AdminStatusLiveliness": AdminStatusLiveliness,
    "AdminStatusReadiness": AdminStatusReadiness,
    "AttachDecorator": AttachDecorator,
    "AttachDecoratorData": AttachDecoratorData,
    "AttachDecoratorData1JWS": AttachDecoratorData1JWS,
    "AttachDecoratorDataJWS": AttachDecoratorDataJWS,
    "AttachDecoratorDataJWSHeader": AttachDecoratorDataJWSHeader,
    "AttachmentDef": AttachmentDef,
    "AttributeMimeTypesResult": AttributeMimeTypesResult,
    "BasicMessageModuleResponse": BasicMessageModuleResponse,
    "ClaimFormat": ClaimFormat,
    "ClearPendingRevocationsRequest": ClearPendingRevocationsRequest,
    "ConnRecord": ConnRecord,
    "ConnectionInvitation": ConnectionInvitation,
    "ConnectionList": ConnectionList,
    "ConnectionMetadata": ConnectionMetadata,
    "ConnectionMetadataSetRequest": ConnectionMetadataSetRequest,
    "ConnectionModuleResponse": ConnectionModuleResponse,
    "ConnectionStaticRequest": ConnectionStaticRequest,
    "ConnectionStaticResult": ConnectionStaticResult,
    "Constraints": Constraints,
    "CreateInvitationRequest": CreateInvitationRequest,
    "CredAttrSpec": CredAttrSpec,
    "CredDefValue": CredDefValue,
    "CredDefValuePrimary": CredDefValuePrimary,
    "CredDefValueRevocation": CredDefValueRevocation,
    "CredInfoList": CredInfoList,
    "CredRevRecordResult": CredRevRecordResult,
    "CredRevokedResult": CredRevokedResult,
    "Credential": Credential,
    "CredentialDefinition": CredentialDefinition,
    "CredentialDefinitionGetResult": CredentialDefinitionGetResult,
    "CredentialDefinitionSendRequest": CredentialDefinitionSendRequest,
    "CredentialDefinitionSendResult": CredentialDefinitionSendResult,
    "CredentialDefinitionsCreatedResult": CredentialDefinitionsCreatedResult,
    "CredentialOffer": CredentialOffer,
    "CredentialPreview": CredentialPreview,
    "CredentialProposal": CredentialProposal,
    "CredentialStatusOptions": CredentialStatusOptions,
    "DID": DID,
    "DIDCreate": DIDCreate,
    "DIDCreateOptions": DIDCreateOptions,
    "DIDEndpoint": DIDEndpoint,
    "DIDEndpointWithType": DIDEndpointWithType,
    "DIDList": DIDList,
    "DIDResult": DIDResult,
    "DIDXRequest": DIDXRequest,
    "DIFField": DIFField,
    "DIFHolder": DIFHolder,
    "DIFOptions": DIFOptions,
    "DIFPresSpec": DIFPresSpec,
    "DIFProofProposal": DIFProofProposal,
    "DIFProofRequest": DIFProofRequest,
    "Disclose": Disclose,
    "Disclosures": Disclosures,
    "Doc": Doc,
    "EndorserInfo": EndorserInfo,
    "EndpointsResult": EndpointsResult,
    "Filter": Filter,
    "Generated": Generated,
    "GetDIDEndpointResponse": GetDIDEndpointResponse,
    "GetDIDVerkeyResponse": GetDIDVerkeyResponse,
    "GetNymRoleResponse": GetNymRoleResponse,
    "HolderModuleResponse": HolderModuleResponse,
    "IndyAttrValue": IndyAttrValue,
    "IndyCredAbstract": IndyCredAbstract,
    "IndyCredInfo": IndyCredInfo,
    "IndyCredPrecis": IndyCredPrecis,
    "IndyCredRequest": IndyCredRequest,
    "IndyCredential": IndyCredential,
    "IndyEQProof": IndyEQProof,
    "IndyGEProof": IndyGEProof,
    "IndyGEProofPred": IndyGEProofPred,
    "IndyKeyCorrectnessProof": IndyKeyCorrectnessProof,
    "IndyNonRevocProof": IndyNonRevocProof,
    "IndyNonRevocationInterval": IndyNonRevocationInterval,
    "IndyPresAttrSpec": IndyPresAttrSpec,
    "IndyPresPredSpec": IndyPresPredSpec,
    "IndyPresPreview": IndyPresPreview,
    "IndyPresSpec": IndyPresSpec,
    "IndyPrimaryProof": IndyPrimaryProof,
    "IndyProof": IndyProof,
    "IndyProofIdentifier": IndyProofIdentifier,
    "IndyProofProof": IndyProofProof,
    "IndyProofProofAggregatedProof": IndyProofProofAggregatedProof,
    "IndyProofProofProofsProof": IndyProofProofProofsProof,
    "IndyProofReqAttrSpec": IndyProofReqAttrSpec,
    "IndyProofReqAttrSpecNonRevoked": IndyProofReqAttrSpecNonRevoked,
    "IndyProofReqPredSpec": IndyProofReqPredSpec,
    "IndyProofReqPredSpecNonRevoked": IndyProofReqPredSpecNonRevoked,
    "IndyProofRequest": IndyProofRequest,
    "IndyProofRequestNonRevoked": IndyProofRequestNonRevoked,
    "IndyProofRequestedProof": IndyProofRequestedProof,
    "IndyProofRequestedProofPredicate": IndyProofRequestedProofPredicate,
    "IndyProofRequestedProofRevealedAttr": IndyProofRequestedProofRevealedAttr,
    "IndyProofRequestedProofRevealedAttrGroup": IndyProofRequestedProofRevealedAttrGroup,
    "IndyRequestedCredsRequestedAttr": IndyRequestedCredsRequestedAttr,
    "IndyRequestedCredsRequestedPred": IndyRequestedCredsRequestedPred,
    "IndyRevRegDef": IndyRevRegDef,
    "IndyRevRegDefValue": IndyRevRegDefValue,
    "IndyRevRegDefValuePublicKeys": IndyRevRegDefValuePublicKeys,
    "IndyRevRegDefValuePublicKeysAccumKey": IndyRevRegDefValuePublicKeysAccumKey,
    "IndyRevRegEntry": IndyRevRegEntry,
    "IndyRevRegEntryValue": IndyRevRegEntryValue,
    "InputDescriptors": InputDescriptors,
    "IntroModuleResponse": IntroModuleResponse,
    "InvitationCreateRequest": InvitationCreateRequest,
    "InvitationMessage": InvitationMessage,
    "InvitationRecord": InvitationRecord,
    "InvitationResult": InvitationResult,
    "IssueCredentialModuleResponse": IssueCredentialModuleResponse,
    "IssuerCredRevRecord": IssuerCredRevRecord,
    "IssuerRevRegRecord": IssuerRevRegRecord,
    "Keylist": Keylist,
    "KeylistQuery": KeylistQuery,
    "KeylistQueryFilterRequest": KeylistQueryFilterRequest,
    "KeylistQueryPaginate": KeylistQueryPaginate,
    "KeylistUpdate": KeylistUpdate,
    "KeylistUpdateRequest": KeylistUpdateRequest,
    "KeylistUpdateRule": KeylistUpdateRule,
    "LDProofVCDetail": LDProofVCDetail,
    "LDProofVCDetailOptions": LDProofVCDetailOptions,
    "LedgerConfigInstance": LedgerConfigInstance,
    "LedgerConfigList": LedgerConfigList,
    "LedgerModulesResult": LedgerModulesResult,
    "LinkedDataProof": LinkedDataProof,
    "MediationCreateRequest": MediationCreateRequest,
    "MediationDeny": MediationDeny,
    "MediationGrant": MediationGrant,
    "MediationList": MediationList,
    "MediationRecord": MediationRecord,
    "Menu": Menu,
    "MenuForm": MenuForm,
    "MenuFormParam": MenuFormParam,
    "MenuJson": MenuJson,
    "MenuOption": MenuOption,
    "ModelDate": ModelDate,
    "PerformRequest": PerformRequest,
    "PingRequest": PingRequest,
    "PingRequestResponse": PingRequestResponse,
    "PresentationDefinition": PresentationDefinition,
    "PresentationProposal": PresentationProposal,
    "PresentationRequest": PresentationRequest,
    "ProtocolDescriptor": ProtocolDescriptor,
    "PublishRevocations": PublishRevocations,
    "Queries": Queries,
    "Query": Query,
    "QueryItem": QueryItem,
    "RawEncoded": RawEncoded,
    "ReceiveInvitationRequest": ReceiveInvitationRequest,
    "RegisterLedgerNymResponse": RegisterLedgerNymResponse,
    "ResolutionResult": ResolutionResult,
    "RevRegCreateRequest": RevRegCreateRequest,
    "RevRegIssuedResult": RevRegIssuedResult,
    "RevRegResult": RevRegResult,
    "RevRegUpdateTailsFileUri": RevRegUpdateTailsFileUri,
    "RevRegsCreated": RevRegsCreated,
    "RevocationModuleResponse": RevocationModuleResponse,
    "RevokeRequest": RevokeRequest,
    "RouteRecord": RouteRecord,
    "Schema": Schema,
    "SchemaGetResult": SchemaGetResult,
    "SchemaInputDescriptor": SchemaInputDescriptor,
    "SchemaSendRequest": SchemaSendRequest,
    "SchemaSendResult": SchemaSendResult,
    "SchemasCreatedResult": SchemasCreatedResult,
    "SchemasInputDescriptorFilter": SchemasInputDescriptorFilter,
    "SendMenu": SendMenu,
    "SendMessage": SendMessage,
    "SignRequest": SignRequest,
    "SignResponse": SignResponse,
    "SignatureOptions": SignatureOptions,
    "SignedDoc": SignedDoc,
    "SubmissionRequirements": SubmissionRequirements,
    "TAAAccept": TAAAccept,
    "TAAAcceptance": TAAAcceptance,
    "TAAInfo": TAAInfo,
    "TAARecord": TAARecord,
    "TAAResult": TAAResult,
    "TransactionJobs": TransactionJobs,
    "TransactionList": TransactionList,
    "TransactionRecord": TransactionRecord,
    "TxnOrCredentialDefinitionSendResult": TxnOrCredentialDefinitionSendResult,
    "TxnOrPublishRevocationsResult": TxnOrPublishRevocationsResult,
    "TxnOrRevRegResult": TxnOrRevRegResult,
    "TxnOrSchemaSendResult": TxnOrSchemaSendResult,
    "V10CredentialBoundOfferRequest": V10CredentialBoundOfferRequest,
    "V10CredentialConnFreeOfferRequest": V10CredentialConnFreeOfferRequest,
    "V10CredentialCreate": V10CredentialCreate,
    "V10CredentialExchange": V10CredentialExchange,
    "V10CredentialExchangeListResult": V10CredentialExchangeListResult,
    "V10CredentialFreeOfferRequest": V10CredentialFreeOfferRequest,
    "V10CredentialIssueRequest": V10CredentialIssueRequest,
    "V10CredentialProblemReportRequest": V10CredentialProblemReportRequest,
    "V10CredentialProposalRequestMand": V10CredentialProposalRequestMand,
    "V10CredentialProposalRequestOpt": V10CredentialProposalRequestOpt,
    "V10CredentialStoreRequest": V10CredentialStoreRequest,
    "V10DiscoveryExchangeListResult": V10DiscoveryExchangeListResult,
    "V10DiscoveryExchangeResult": V10DiscoveryExchangeResult,
    "V10DiscoveryRecord": V10DiscoveryRecord,
    "V10PresentProofModuleResponse": V10PresentProofModuleResponse,
    "V10PresentationCreateRequestRequest": V10PresentationCreateRequestRequest,
    "V10PresentationExchange": V10PresentationExchange,
    "V10PresentationExchangeList": V10PresentationExchangeList,
    "V10PresentationProblemReportRequest": V10PresentationProblemReportRequest,
    "V10PresentationProposalRequest": V10PresentationProposalRequest,
    "V10PresentationSendRequestRequest": V10PresentationSendRequestRequest,
    "V20CredAttrSpec": V20CredAttrSpec,
    "V20CredBoundOfferRequest": V20CredBoundOfferRequest,
    "V20CredExFree": V20CredExFree,
    "V20CredExRecord": V20CredExRecord,
    "V20CredExRecordByFormat": V20CredExRecordByFormat,
    "V20CredExRecordDetail": V20CredExRecordDetail,
    "V20CredExRecordIndy": V20CredExRecordIndy,
    "V20CredExRecordLDProof": V20CredExRecordLDProof,
    "V20CredExRecordListResult": V20CredExRecordListResult,
    "V20CredFilter": V20CredFilter,
    "V20CredFilterIndy": V20CredFilterIndy,
    "V20CredFilterLDProof": V20CredFilterLDProof,
    "V20CredFormat": V20CredFormat,
    "V20CredIssue": V20CredIssue,
    "V20CredIssueProblemReportRequest": V20CredIssueProblemReportRequest,
    "V20CredIssueRequest": V20CredIssueRequest,
    "V20CredOffer": V20CredOffer,
    "V20CredOfferConnFreeRequest": V20CredOfferConnFreeRequest,
    "V20CredOfferRequest": V20CredOfferRequest,
    "V20CredPreview": V20CredPreview,
    "V20CredProposal": V20CredProposal,
    "V20CredRequest": V20CredRequest,
    "V20CredRequestFree": V20CredRequestFree,
    "V20CredRequestRequest": V20CredRequestRequest,
    "V20CredStoreRequest": V20CredStoreRequest,
    "V20DiscoveryExchangeListResult": V20DiscoveryExchangeListResult,
    "V20DiscoveryExchangeResult": V20DiscoveryExchangeResult,
    "V20DiscoveryRecord": V20DiscoveryRecord,
    "V20IssueCredSchemaCore": V20IssueCredSchemaCore,
    "V20IssueCredentialModuleResponse": V20IssueCredentialModuleResponse,
    "V20Pres": V20Pres,
    "V20PresCreateRequestRequest": V20PresCreateRequestRequest,
    "V20PresExRecord": V20PresExRecord,
    "V20PresExRecordByFormat": V20PresExRecordByFormat,
    "V20PresExRecordList": V20PresExRecordList,
    "V20PresFormat": V20PresFormat,
    "V20PresProblemReportRequest": V20PresProblemReportRequest,
    "V20PresProposal": V20PresProposal,
    "V20PresProposalByFormat": V20PresProposalByFormat,
    "V20PresProposalRequest": V20PresProposalRequest,
    "V20PresRequest": V20PresRequest,
    "V20PresRequestByFormat": V20PresRequestByFormat,
    "V20PresSendRequestRequest": V20PresSendRequestRequest,
    "V20PresSpecByFormatRequest": V20PresSpecByFormatRequest,
    "V20PresentProofModuleResponse": V20PresentProofModuleResponse,
    "VCRecord": VCRecord,
    "VCRecordList": VCRecordList,
    "VerifyRequest": VerifyRequest,
    "VerifyResponse": VerifyResponse,
    "W3CCredentialsListRequest": W3CCredentialsListRequest,
    "WalletModuleResponse": WalletModuleResponse,
    "WriteLedgerRequest": WriteLedgerRequest,
}
